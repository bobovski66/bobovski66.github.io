<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fisher Geometry Curvature Explorer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            background: rgba(255, 255, 255, 0.15);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .control-group h3 {
            margin-top: 0;
            color: #4ecdc4;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .slider-container {
            margin: 15px 0;
        }
        
        .slider-container label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
        }
        
        .slider {
            width: 100%;
            -webkit-appearance: none;
            height: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
            margin-bottom: 10px;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            cursor: pointer;
            border: none;
        }
        
        select, button {
            padding: 12px;
            border-radius: 8px;
            border: none;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        select:hover, button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        
        button {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            padding: 15px 30px;
            font-size: 16px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .visualization-area {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
        }
        
        .plot-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .info-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .metric-display {
            font-family: 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            white-space: pre-line;
            font-size: 14px;
        }
        
        .status {
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            margin: 10px 0;
        }
        
        .help-toggle {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .help-panel {
            background: rgba(255, 255, 255, 0.12);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(15px);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            transform-origin: top;
            overflow: hidden;
        }
        
        .help-panel.hidden {
            max-height: 0;
            padding: 0 25px;
            margin-bottom: 0;
            opacity: 0;
            transform: scaleY(0);
        }
        
        .help-panel:not(.hidden) {
            max-height: 800px;
            opacity: 1;
            transform: scaleY(1);
        }
        
        .help-section {
            margin: 20px 0;
        }
        
        .help-section h4 {
            color: #4ecdc4;
            margin-bottom: 12px;
            font-size: 1.1em;
        }
        
        .help-section ol, .help-section ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .help-section li {
            margin: 8px 0;
            line-height: 1.5;
        }
        
        .color-indicator {
            display: inline-block;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            vertical-align: middle;
        }
        
        .color-indicator.hot {
            background: linear-gradient(45deg, #ff6b6b, #ffa726);
        }
        
        .color-indicator.cool {
            background: linear-gradient(45deg, #42a5f5, #7e57c2);
        }
        
        #helpButton {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 14px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        #helpButton:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        @media (max-width: 600px) {
            .controls {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üåä Fisher Geometry Curvature Explorer</h1>
        
        <div class="help-toggle">
            <button onclick="toggleHelp()" id="helpButton">‚ùì What is this?</button>
        </div>
        
        <div id="helpPanel" class="help-panel hidden">
            <h3>üß† What it's doing, succinctly:</h3>
            <p><strong>It's visualizing the "bumpiness" of a neural network's loss landscape.</strong></p>
            
            <div class="help-section">
                <h4>Core idea:</h4>
                <ol>
                    <li><strong>Multi-head setup</strong>: Think of 3-5 different "expert" networks, each with their own weights</li>
                    <li><strong>Smart blending</strong>: A gating function decides how much to trust each expert at different points in parameter space</li>
                    <li><strong>Fisher geometry</strong>: Uses probability theory to measure how "curved" or "bumpy" the combined loss surface is at each point</li>
                    <li><strong>Interactive exploration</strong>: You can adjust the experts and gating to see how it changes the landscape's geometry</li>
                </ol>
            </div>
            
            <div class="help-section">
                <h4>üåà The colors show:</h4>
                <ul>
                    <li><span class="color-indicator hot"></span> <strong>Red/Yellow</strong>: Very curved, difficult optimization (imagine steep hills)</li>
                    <li><span class="color-indicator cool"></span> <strong>Blue/Purple</strong>: Flatter regions, easier optimization (imagine gentle valleys)</li>
                </ul>
            </div>
            
            <div class="help-section">
                <h4>üéØ Why it matters:</h4>
                <p>This geometry tells you where gradient descent will struggle (high curvature) vs. where it will flow smoothly (low curvature). It's like having a <strong>topographical map</strong> of your neural network's optimization landscape.</p>
                <p>The interactive controls let you see how different architectural choices (number of heads, gating strength, etc.) create completely different geometric landscapes for optimization.</p>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <h3>üéØ Head Parameters</h3>
                <div class="slider-container">
                    <label>Number of Heads: <span id="numHeadsValue">3</span></label>
                    <input type="range" id="numHeads" class="slider" min="2" max="5" value="3">
                </div>
                <div class="slider-container">
                    <label>Head Strength: <span id="headStrengthValue">1.0</span></label>
                    <input type="range" id="headStrength" class="slider" min="0.5" max="2.0" step="0.1" value="1.0">
                </div>
            </div>
            
            <div class="control-group">
                <h3>üîÆ Gating Control</h3>
                <div class="slider-container">
                    <label>Gating Strength: <span id="gatingStrengthValue">1.0</span></label>
                    <input type="range" id="gatingStrength" class="slider" min="0.2" max="3.0" step="0.1" value="1.0">
                </div>
                <div class="slider-container">
                    <label>Nonlinearity: <span id="nonlinearityValue">1.0</span></label>
                    <input type="range" id="nonlinearity" class="slider" min="0.5" max="2.0" step="0.1" value="1.0">
                </div>
            </div>
            
            <div class="control-group">
                <h3>üìä Visualization</h3>
                <select id="visualMode">
                    <option value="curvature">Scalar Curvature</option>
                    <option value="gating">Gating Weights</option>
                    <option value="metric_det">Metric Determinant</option>
                    <option value="metric_trace">Metric Trace</option>
                </select>
                <div class="slider-container">
                    <label>Resolution: <span id="resolutionValue">40</span></label>
                    <input type="range" id="resolution" class="slider" min="20" max="80" step="5" value="40">
                </div>
            </div>
            
            <div class="control-group">
                <h3>üéÆ Actions</h3>
                <button onclick="randomizeParameters()">üé≤ Randomize</button>
                <button onclick="resetParameters()">üîÑ Reset</button>
                <button onclick="updateVisualization()">üöÄ Update</button>
            </div>
        </div>
        
        <div class="visualization-area">
            <div class="plot-container">
                <div id="plotly-div" style="width: 100%; height: 500px;"></div>
            </div>
            
            <div class="info-panel">
                <h3>üìà Analysis</h3>
                <div class="status" id="status">Ready to compute...</div>
                
                <h4>Current Point Metrics</h4>
                <div class="metric-display" id="pointMetrics">
Click on the plot to see metrics at that point
                </div>
                
                <h4>Global Statistics</h4>
                <div class="metric-display" id="globalStats">
Run computation to see statistics
                </div>
            </div>
        </div>
    </div>

    <script>
        // Core mathematical functions
        function softmax(z) {
            const maxZ = Math.max(...z);
            const exp_z = z.map(x => Math.exp(x - maxZ));
            const sum = exp_z.reduce((a, b) => a + b, 0);
            return exp_z.map(x => x / sum);
        }
        
        function covFromP(p) {
            const n = p.length;
            const C = Array(n).fill(0).map(() => Array(n).fill(0));
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    C[i][j] = (i === j ? p[i] : 0) - p[i] * p[j];
                }
            }
            return C;
        }
        
        function matmul(A, B) {
            const rows = A.length;
            const cols = B[0].length;
            const inner = B.length;
            const result = Array(rows).fill(0).map(() => Array(cols).fill(0));
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    for (let k = 0; k < inner; k++) {
                        result[i][j] += A[i][k] * B[k][j];
                    }
                }
            }
            return result;
        }
        
        function transpose(A) {
            return A[0].map((_, j) => A.map(row => row[j]));
        }
        
        function phi(h, nonlinearity = 1.0) {
            const [u, v] = h;
            const nl = nonlinearity;
            return [1.0, u, v, nl * u * u, nl * v * v, nl * u * v];
        }
        
        function headMetric(W, h) {
            // Compute x = W @ h
            const x = W.map(row => row[0] * h[0] + row[1] * h[1]);
            const p = softmax(x);
            const C = covFromP(p);
            
            // g = W^T @ C @ W
            const WT = transpose(W);
            const temp = matmul(WT, C);
            const g = matmul(temp, W);
            
            return g;
        }
        
        function gatingWeights(U, h, nonlinearity) {
            const features = phi(h, nonlinearity);
            const z = U.map(row => row.reduce((sum, val, i) => sum + val * features[i], 0));
            return softmax(z);
        }
        
        function effectiveMetric(W_list, U, h, gatingStrength, nonlinearity) {
            const alpha = gatingWeights(U, h, nonlinearity);
            let g = [[0, 0], [0, 0]];
            
            for (let i = 0; i < W_list.length; i++) {
                const g_head = headMetric(W_list[i], h);
                const weight = Math.pow(alpha[i], gatingStrength);
                
                for (let j = 0; j < 2; j++) {
                    for (let k = 0; k < 2; k++) {
                        g[j][k] += weight * g_head[j][k];
                    }
                }
            }
            
            return { metric: g, weights: alpha };
        }
        
        function matrixInverse2x2(m) {
            const det = m[0][0] * m[1][1] - m[0][1] * m[1][0];
            if (Math.abs(det) < 1e-12) return null;
            
            return [
                [ m[1][1] / det, -m[0][1] / det],
                [-m[1][0] / det,  m[0][0] / det]
            ];
        }
        
        function approximateScalarCurvature(W_list, U, h, gatingStrength, nonlinearity, epsilon = 1e-6) {
            const center = effectiveMetric(W_list, U, h, gatingStrength, nonlinearity);
            const g = center.metric;
            const inv = matrixInverse2x2(g);
            
            if (!inv) return 0;
            
            // Simple finite difference approximation for curvature
            const du = epsilon;
            const dv = epsilon;
            
            const g_uu = effectiveMetric(W_list, U, [h[0] + du, h[1]], gatingStrength, nonlinearity).metric;
            const g_uv = effectiveMetric(W_list, U, [h[0], h[1] + dv], gatingStrength, nonlinearity).metric;
            const g_vv = effectiveMetric(W_list, U, [h[0] - du, h[1]], gatingStrength, nonlinearity).metric;
            const g_vu = effectiveMetric(W_list, U, [h[0], h[1] - dv], gatingStrength, nonlinearity).metric;
            
            // Approximate second derivatives
            let curvature = 0;
            for (let i = 0; i < 2; i++) {
                for (let j = 0; j < 2; j++) {
                    const d2g_dudv = (g_uu[i][j] + g_vv[i][j] - 2 * g[i][j]) / (du * du) +
                                     (g_uv[i][j] + g_vu[i][j] - 2 * g[i][j]) / (dv * dv);
                    curvature += inv[i][j] * d2g_dudv;
                }
            }
            
            return curvature * 0.5; // Normalization factor
        }
        
        // Global state
        let currentData = null;
        let W_list = [];
        let U = [];
        
        function generateRandomMatrix(rows, cols, scale = 1.0) {
            return Array(rows).fill(0).map(() => 
                Array(cols).fill(0).map(() => (Math.random() - 0.5) * 2 * scale)
            );
        }
        
        function initializeParameters() {
            const numHeads = parseInt(document.getElementById('numHeads').value);
            const headStrength = parseFloat(document.getElementById('headStrength').value);
            
            // Generate weight matrices for each head (K=3 classes, 2D input)
            W_list = [];
            for (let i = 0; i < numHeads; i++) {
                W_list.push(generateRandomMatrix(3, 2, headStrength));
            }
            
            // Generate gating matrix (numHeads outputs, 6 polynomial features)
            U = generateRandomMatrix(numHeads, 6, 1.0);
        }
        
        function updateVisualization() {
            const status = document.getElementById('status');
            status.textContent = 'Computing...';
            status.style.background = 'rgba(255, 165, 0, 0.3)';
            
            setTimeout(() => {
                try {
                    initializeParameters();
                    const resolution = parseInt(document.getElementById('resolution').value);
                    const visualMode = document.getElementById('visualMode').value;
                    const gatingStrength = parseFloat(document.getElementById('gatingStrength').value);
                    const nonlinearity = parseFloat(document.getElementById('nonlinearity').value);
                    
                    const extent = 2.0;
                    const us = [];
                    const vs = [];
                    
                    for (let i = 0; i < resolution; i++) {
                        us.push(-extent + (2 * extent * i) / (resolution - 1));
                        vs.push(-extent + (2 * extent * i) / (resolution - 1));
                    }
                    
                    const data = Array(resolution).fill(0).map(() => Array(resolution).fill(0));
                    let minVal = Infinity, maxVal = -Infinity;
                    
                    for (let i = 0; i < resolution; i++) {
                        for (let j = 0; j < resolution; j++) {
                            const h = [us[i], vs[j]];
                            let value;
                            
                            switch (visualMode) {
                                case 'curvature':
                                    value = approximateScalarCurvature(W_list, U, h, gatingStrength, nonlinearity);
                                    break;
                                case 'gating':
                                    const weights = gatingWeights(U, h, nonlinearity);
                                    value = Math.max(...weights) - Math.min(...weights); // weight dispersion
                                    break;
                                case 'metric_det':
                                    const result_det = effectiveMetric(W_list, U, h, gatingStrength, nonlinearity);
                                    const g_det = result_det.metric;
                                    value = Math.log(Math.abs(g_det[0][0] * g_det[1][1] - g_det[0][1] * g_det[1][0]) + 1e-12);
                                    break;
                                case 'metric_trace':
                                    const result_tr = effectiveMetric(W_list, U, h, gatingStrength, nonlinearity);
                                    const g_tr = result_tr.metric;
                                    value = g_tr[0][0] + g_tr[1][1];
                                    break;
                                default:
                                    value = 0;
                            }
                            
                            if (isFinite(value)) {
                                data[i][j] = value;
                                minVal = Math.min(minVal, value);
                                maxVal = Math.max(maxVal, value);
                            }
                        }
                    }
                    
                    currentData = { data, us, vs, minVal, maxVal };
                    
                    const trace = {
                        z: data,
                        x: us,
                        y: vs,
                        type: 'heatmap',
                        colorscale: 'Viridis',
                        hovertemplate: 'u: %{x:.3f}<br>v: %{y:.3f}<br>Value: %{z:.4f}<extra></extra>'
                    };
                    
                    const layout = {
                        title: {
                            text: `${visualMode.charAt(0).toUpperCase() + visualMode.slice(1).replace('_', ' ')}`,
                            font: { color: 'white', size: 18 }
                        },
                        paper_bgcolor: 'rgba(0,0,0,0)',
                        plot_bgcolor: 'rgba(0,0,0,0.3)',
                        xaxis: { title: 'u', color: 'white', gridcolor: 'rgba(255,255,255,0.2)' },
                        yaxis: { title: 'v', color: 'white', gridcolor: 'rgba(255,255,255,0.2)' },
                        font: { color: 'white' }
                    };
                    
                    const config = { responsive: true, displayModeBar: false };
                    
                    Plotly.newPlot('plotly-div', [trace], layout, config);
                    
                    // Add click handler
                    document.getElementById('plotly-div').on('plotly_click', function(data) {
                        const point = data.points[0];
                        analyzePoint([point.x, point.y]);
                    });
                    
                    updateGlobalStats();
                    
                    status.textContent = 'Computation complete!';
                    status.style.background = 'rgba(76, 175, 80, 0.3)';
                    
                } catch (error) {
                    status.textContent = 'Error: ' + error.message;
                    status.style.background = 'rgba(244, 67, 54, 0.3)';
                }
            }, 100);
        }
        
        function analyzePoint(h) {
            if (!W_list.length) return;
            
            const gatingStrength = parseFloat(document.getElementById('gatingStrength').value);
            const nonlinearity = parseFloat(document.getElementById('nonlinearity').value);
            
            const result = effectiveMetric(W_list, U, h, gatingStrength, nonlinearity);
            const g = result.metric;
            const weights = result.weights;
            const curvature = approximateScalarCurvature(W_list, U, h, gatingStrength, nonlinearity);
            
            const det = g[0][0] * g[1][1] - g[0][1] * g[1][0];
            const trace = g[0][0] + g[1][1];
            
            const metrics = `Point: [${h[0].toFixed(3)}, ${h[1].toFixed(3)}]
            
Metric Matrix:
[${g[0][0].toFixed(4)}  ${g[0][1].toFixed(4)}]
[${g[1][0].toFixed(4)}  ${g[1][1].toFixed(4)}]

Determinant: ${det.toFixed(6)}
Trace: ${trace.toFixed(4)}
Scalar Curvature: ${curvature.toFixed(6)}

Gating Weights:
${weights.map((w, i) => `Head ${i+1}: ${w.toFixed(4)}`).join('\n')}`;
            
            document.getElementById('pointMetrics').textContent = metrics;
        }
        
        function updateGlobalStats() {
            if (!currentData) return;
            
            const { data, minVal, maxVal } = currentData;
            const flatData = data.flat().filter(x => isFinite(x));
            
            const mean = flatData.reduce((a, b) => a + b, 0) / flatData.length;
            const variance = flatData.reduce((a, b) => a + (b - mean) ** 2, 0) / flatData.length;
            const std = Math.sqrt(variance);
            
            const stats = `Range: [${minVal.toFixed(4)}, ${maxVal.toFixed(4)}]
Mean: ${mean.toFixed(6)}
Std Dev: ${std.toFixed(6)}
Data Points: ${flatData.length}
Heads: ${W_list.length}`;
            
            document.getElementById('globalStats').textContent = stats;
        }
        
        function randomizeParameters() {
            document.getElementById('numHeads').value = Math.floor(Math.random() * 4) + 2;
            document.getElementById('headStrength').value = (Math.random() * 1.5 + 0.5).toFixed(1);
            document.getElementById('gatingStrength').value = (Math.random() * 2.8 + 0.2).toFixed(1);
            document.getElementById('nonlinearity').value = (Math.random() * 1.5 + 0.5).toFixed(1);
            updateSliderDisplays();
        }
        
        function resetParameters() {
            document.getElementById('numHeads').value = 3;
            document.getElementById('headStrength').value = 1.0;
            document.getElementById('gatingStrength').value = 1.0;
            document.getElementById('nonlinearity').value = 1.0;
            document.getElementById('resolution').value = 40;
            document.getElementById('visualMode').value = 'curvature';
            updateSliderDisplays();
        }
        
        function updateSliderDisplays() {
            const sliders = ['numHeads', 'headStrength', 'gatingStrength', 'nonlinearity', 'resolution'];
            sliders.forEach(id => {
                const slider = document.getElementById(id);
                const display = document.getElementById(id + 'Value');
                if (display) display.textContent = slider.value;
            });
        }
        
        function toggleHelp() {
            const helpPanel = document.getElementById('helpPanel');
            const helpButton = document.getElementById('helpButton');
            
            if (helpPanel.classList.contains('hidden')) {
                helpPanel.classList.remove('hidden');
                helpButton.textContent = '‚ùå Hide explanation';
            } else {
                helpPanel.classList.add('hidden');
                helpButton.textContent = '‚ùì What is this?';
            }
        }
        
        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            const sliders = document.querySelectorAll('.slider');
            sliders.forEach(slider => {
                slider.addEventListener('input', updateSliderDisplays);
            });
            
            document.getElementById('visualMode').addEventListener('change', updateVisualization);
            
            updateSliderDisplays();
            updateVisualization();
        });
    </script>
</body>
</html>