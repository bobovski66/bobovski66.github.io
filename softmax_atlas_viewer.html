<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Softmax Atlas Viewer — Sphere, Torus, RP²</title>
  <style>
    :root {
      --bg: #0b0f14;
      --fg: #e6edf3;
      --muted: #9aa5b1;
      --accent: #6aa9ff;
      --panel: #121821;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; font: 14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: var(--bg); color: var(--fg);
      display: grid; grid-template-rows: auto 1fr; gap: 10px;
    }
    header { padding: 12px 16px; background: var(--panel); box-shadow: 0 1px 0 rgba(255,255,255,0.06) inset; }
    header h1 { margin: 0; font-size: 18px; font-weight: 600; letter-spacing: 0.2px; }
    header p { margin: 2px 0 0; color: var(--muted); font-size: 12px; }

    .controls {
      display: flex; flex-wrap: wrap; gap: 16px; align-items: center; padding: 8px 16px 12px; background: #0e1520;
      border-top: 1px solid rgba(255,255,255,0.05);
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    .control { display: grid; gap: 6px; }
    .control label { font-size: 12px; color: var(--muted); }
    select, input[type="range"], button {
      appearance: none; background: var(--panel); color: var(--fg); border: 1px solid rgba(255,255,255,0.08);
      padding: 8px 10px; border-radius: 10px; outline: none;
    }
    input[type="range"] { width: 280px; height: 8px; padding: 0; }
    .row { display: flex; gap: 16px; align-items: center; flex-wrap: wrap; }
    .spacer { flex: 1; }

    #canvasWrap { position: relative; }
    canvas { display: block; width: 100%; height: 100%; background: radial-gradient(1200px 800px at 30% 0%, #111827, #0b0f14 60%); }
    .hint { position: absolute; bottom: 10px; left: 12px; color: #c0cad5; font-size: 12px; opacity: 0.8; }
    .badge { padding: 2px 8px; background: rgba(255,255,255,0.08); border-radius: 999px; margin-left: 8px; font-size: 11px; color: #c9d3df; }
  </style>
</head>
<body>
  <header>
    <h1>Softmax Atlas Viewer <span class="badge">Sphere · Torus · RP²</span></h1>
    <p>Graticules drawn in softmax/Gudermannian coordinates; temperature <code>τ</code> rescales the logit direction.</p>
  </header>

  <div class="controls">
    <div class="row">
      <div class="control">
        <label for="surface">Surface</label>
        <select id="surface">
          <option value="sphere">Sphere (Mercator via softmax)</option>
          <option value="torus">Torus (two softmax charts)</option>
          <option value="rp2">Projective plane RP² (Roman immersion)</option>
        </select>
      </div>

      <div class="control">
        <label for="tau">Temperature τ: <span id="tauLabel">1.00</span></label>
        <input id="tau" type="range" min="0.10" max="3.00" value="1.00" step="0.01" />
      </div>

      <div class="control">
        <label for="density">Grid density</label>
        <input id="density" type="range" min="6" max="40" value="18" step="1" />
      </div>

      <div class="control">
        <label for="rotate">Auto-rotate</label>
        <select id="rotate">
          <option value="on">On</option>
          <option value="off">Off</option>
        </select>
      </div>

      <div class="spacer"></div>

      <div class="row">
        <button id="resetView">Reset view</button>
      </div>
    </div>
  </div>

  <div id="canvasWrap" style="height: calc(100vh - 156px);">
    <canvas id="viewport"></canvas>
    <div class="hint">drag to rotate · wheel to zoom · τ rescales latitude in the softmax chart</div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('viewport');
  const ctx = canvas.getContext('2d');

  // UI elements
  const surfaceSel = document.getElementById('surface');
  const tauRange = document.getElementById('tau');
  const tauLabel = document.getElementById('tauLabel');
  const densRange = document.getElementById('density');
  const rotateSel = document.getElementById('rotate');
  const resetBtn = document.getElementById('resetView');

  // Device pixel ratio handling for crisp lines
  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.round(rect.width * dpr);
    canvas.height = Math.round(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // Math helpers (with fallbacks)
  const tanh = Math.tanh ? Math.tanh.bind(Math) : (x) => {
    const e = Math.exp(2*x); return (e - 1) / (e + 1);
  };
  const cosh = Math.cosh ? Math.cosh.bind(Math) : (x) => (Math.exp(x) + Math.exp(-x)) / 2;
  const sech = (x) => 1 / cosh(x);

  // Camera / interaction
  let yaw = 0.6, pitch = 0.3, dist = 4.2, autoRotate = true;
  const rotSpeed = 0.004;

  // Mouse interactions
  let dragging = false, lastX = 0, lastY = 0;
  canvas.addEventListener('mousedown', e => { dragging = true; lastX = e.clientX; lastY = e.clientY; });
  window.addEventListener('mouseup', () => dragging = false);
  window.addEventListener('mousemove', e => {
    if (!dragging) return;
    const dx = e.clientX - lastX; const dy = e.clientY - lastY;
    lastX = e.clientX; lastY = e.clientY;
    yaw += dx * 0.005; pitch += dy * 0.005;
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    pitch = clamp(pitch, -1.2, 1.2);
  });
  canvas.addEventListener('wheel', e => { e.preventDefault(); dist *= (1 + Math.sign(e.deltaY) * 0.08); dist = Math.max(1.5, Math.min(12, dist)); }, { passive: false });
  resetBtn.addEventListener('click', () => { yaw = 0.6; pitch = 0.3; dist = 4.2; });

  rotateSel.addEventListener('change', () => { autoRotate = rotateSel.value === 'on'; });

  // UI change listeners
  tauRange.addEventListener('input', () => { tauLabel.textContent = Number(tauRange.value).toFixed(2); });

  // Projection helpers
  function rotatePoint([x,y,z]) {
    const cy = Math.cos(yaw), sy = Math.sin(yaw);
    const cx = Math.cos(pitch), sx = Math.sin(pitch);
    // Yaw around Z, then pitch around X
    let X =  cy*x - sy*y;
    let Y =  sy*x + cy*y;
    let Z =  z;
    let Y2 =  cx*Y - sx*Z;
    let Z2 =  sx*Y + cx*Z;
    return [X, Y2, Z2];
  }
  function project([x,y,z]) {
    // Simple perspective projection
    const f = 1.2; // focal length in world units
    const zc = z + dist; // camera at (0,0,dist)
    const s = (canvas.width / (window.devicePixelRatio || 1)) * 0.35;
    const px = (x * f / zc) * s + canvas.getBoundingClientRect().width/2;
    const py = (y * f / zc) * s + canvas.getBoundingClientRect().height/2;
    return [px, py, zc];
  }

  // Parametric surfaces in softmax coords
  function spherePoint(u, th, tau) {
    const a = u / (2*tau);
    const x = sech(a) * Math.cos(th);
    const y = sech(a) * Math.sin(th);
    const z = tanh(a);
    return [x, y, z];
  }

  function torusPointN(u, th, R, r, tau) { // North chart
    const a = u / (2*tau);
    const c = sech(a), s = tanh(a);
    const X = (R + r*c) * Math.cos(th);
    const Y = (R + r*c) * Math.sin(th);
    const Z = r * s;
    return [X, Y, Z];
  }
  function torusPointS(u, th, R, r, tau) { // South chart (π shift on minor circle)
    const a = u / (2*tau);
    const c = sech(a), s = tanh(a);
    const X = (R - r*c) * Math.cos(th);
    const Y = (R - r*c) * Math.sin(th);
    const Z = - r * s;
    return [X, Y, Z];
  }

  function romanFromSphere([x,y,z]) { // Steiner / Roman surface immersion RP^2 -> R^3
    return [y*z, z*x, x*y];
  }

  // Drawing utilities
  function drawCurve(points3D) {
    if (points3D.length < 2) return;
    ctx.beginPath();
    for (let i = 0; i < points3D.length; i++) {
      const pr = project(rotatePoint(points3D[i]));
      const [px, py] = pr;
      if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
    }
    ctx.stroke();
  }

  function setStroke(depthHint = 0) {
    // depthHint ∈ [0,1] (0 = far, 1 = near). Light alpha makes back lines recede.
    const alpha = 0.35 + 0.45 * depthHint;
    ctx.strokeStyle = `rgba(220,235,255,${alpha.toFixed(3)})`;
    ctx.lineWidth = 1.1;
  }

  function render() {
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    ctx.clearRect(0, 0, w, h);

    const tau = Number(tauRange.value);
    const density = Math.floor(densRange.value); // number of parallels ~ density, meridians ~ density*1.2

    if (autoRotate) yaw += rotSpeed;

    ctx.save();
    ctx.shadowBlur = 0;

    const UMAX = 7.5; // u-range to approximate the poles
    const Nu = density; // number of u-lines (parallels)
    const Nth = Math.round(density * 1.2); // number of theta-lines (meridians)
    const steps = 480; // samples per curve

    if (surfaceSel.value === 'sphere') {
      // Parallels (u constant)
      for (let i = 0; i < Nu; i++) {
        const u = -UMAX + (2*UMAX)*i/(Nu-1);
        const pts = [];
        for (let j = 0; j <= steps; j++) {
          const th = 2*Math.PI * j/steps;
          pts.push(spherePoint(u, th, tau));
        }
        setStroke(0.7);
        drawCurve(pts);
      }
      // Meridians (theta constant)
      for (let i = 0; i < Nth; i++) {
        const th = 2*Math.PI * i/Nth;
        const pts = [];
        for (let j = 0; j <= steps; j++) {
          const u = -UMAX + (2*UMAX) * j/steps;
          pts.push(spherePoint(u, th, tau));
        }
        setStroke(0.5);
        drawCurve(pts);
      }
    }

    if (surfaceSel.value === 'torus') {
      const R = 2.0, r = 1.0;
      // Parallels (u constant), draw both charts
      for (let i = 0; i < Nu; i++) {
        const u = -UMAX + (2*UMAX)*i/(Nu-1);
        const ptsN = [], ptsS = [];
        for (let j = 0; j <= steps; j++) {
          const th = 2*Math.PI * j/steps;
          ptsN.push(torusPointN(u, th, R, r, tau));
          ptsS.push(torusPointS(u, th, R, r, tau));
        }
        setStroke(0.75); drawCurve(ptsN);
        setStroke(0.70); drawCurve(ptsS);
      }
      // Meridians (theta constant), both charts
      for (let i = 0; i < Nth; i++) {
        const th = 2*Math.PI * i/Nth;
        const ptsN = [], ptsS = [];
        for (let j = 0; j <= steps; j++) {
          const u = -UMAX + (2*UMAX) * j/steps;
          ptsN.push(torusPointN(u, th, 2.0, 1.0, tau));
          ptsS.push(torusPointS(u, th, 2.0, 1.0, tau));
        }
        setStroke(0.55); drawCurve(ptsN);
        setStroke(0.50); drawCurve(ptsS);
      }
    }

    if (surfaceSel.value === 'rp2') {
      // Roman surface via softmax sphere mapping
      // Parallels (u constant)
      for (let i = 0; i < Nu; i++) {
        const u = -UMAX + (2*UMAX)*i/(Nu-1);
        const pts = [];
        for (let j = 0; j <= steps; j++) {
          const th = 2*Math.PI * j/steps;
          pts.push(romanFromSphere(spherePoint(u, th, tau)));
        }
        setStroke(0.75); drawCurve(pts);
      }
      // Meridians (theta constant)
      for (let i = 0; i < Nth; i++) {
        const th = 2*Math.PI * i/Nth;
        const pts = [];
        for (let j = 0; j <= steps; j++) {
          const u = -UMAX + (2*UMAX) * j/steps;
          pts.push(romanFromSphere(spherePoint(u, th, tau)));
        }
        setStroke(0.60); drawCurve(pts);
      }
    }

    ctx.restore();
    requestAnimationFrame(render);
  }

  // Start
  render();
})();
</script>
</body>
</html>
