<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometric Replicator Dynamics - Folded Symplectic Implementation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(to bottom right, #f8fafc, #e2e8f0);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            padding: 24px;
        }
        
        .header {
            margin-bottom: 20px;
        }
        
        .header h1 {
            font-size: 24px;
            color: #1e293b;
            margin-bottom: 4px;
        }
        
        .header p {
            font-size: 14px;
            color: #64748b;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 24px;
        }
        
        @media (max-width: 1400px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
        
        canvas {
            width: 100%;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: #fafafa;
            cursor: move;
        }
        
        .controls {
            background: #f8fafc;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
        }
        
        .controls h3 {
            font-size: 16px;
            color: #1e293b;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .badge {
            font-size: 10px;
            padding: 2px 6px;
            background: #22c55e;
            color: white;
            border-radius: 4px;
            font-weight: 600;
        }
        
        .button-group {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }
        
        button {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
        }
        
        .play-btn {
            flex: 1;
            background: #22c55e;
            color: white;
        }
        
        .play-btn:hover {
            background: #16a34a;
        }
        
        .play-btn.playing {
            background: #ef4444;
        }
        
        .play-btn.playing:hover {
            background: #dc2626;
        }
        
        .reset-btn {
            padding: 10px 16px;
            background: #e2e8f0;
            color: #475569;
        }
        
        .reset-btn:hover {
            background: #cbd5e1;
        }
        
        label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: #1e293b;
            margin-bottom: 8px;
        }
        
        select, input[type="range"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            font-size: 14px;
        }
        
        .slider-group {
            margin-bottom: 12px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 13px;
        }
        
        input[type="range"] {
            padding: 0;
            height: 6px;
        }
        
        .state-box {
            background: #f8fafc;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
        }
        
        .state-box h3 {
            font-size: 16px;
            color: #1e293b;
            margin-bottom: 12px;
        }
        
        .state-row {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            margin-bottom: 8px;
        }
        
        .state-row span:first-child {
            color: #64748b;
        }
        
        .state-row span:last-child {
            font-family: 'Courier New', monospace;
        }
        
        .extinct {
            opacity: 0.4;
            text-decoration: line-through;
        }
        
        .info-box {
            background: #dbeafe;
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            color: #1e40af;
            margin-bottom: 12px;
        }
        
        .info-box p:first-child {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
        }

        .checkbox-group label {
            margin: 0;
            font-weight: normal;
        }

        .geometric-info {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .geometric-info h3 {
            font-size: 16px;
            margin-bottom: 12px;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            margin-bottom: 6px;
            opacity: 0.95;
        }

        .metric-row span:last-child {
            font-family: 'Courier New', monospace;
            font-weight: 600;
        }

        .decomp-viz {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 8px;
        }

        .decomp-bar {
            height: 6px;
            border-radius: 3px;
            background: rgba(255,255,255,0.3);
            overflow: hidden;
        }

        .decomp-fill {
            height: 100%;
            transition: width 0.3s;
        }

        .gradient-fill {
            background: #22c55e;
        }

        .hamiltonian-fill {
            background: #3b82f6;
        }

        .mode-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 16px;
        }

        .mode-btn {
            padding: 8px;
            background: #e2e8f0;
            color: #475569;
            border: 2px solid transparent;
            font-size: 13px;
        }

        .mode-btn.active {
            background: #dbeafe;
            border-color: #3b82f6;
            color: #1e40af;
        }

        .coord-display {
            font-size: 11px;
            color: #64748b;
            margin-top: 4px;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Geometric Replicator Dynamics</h1>
            <p>Folded symplectic implementation with log-ratio coordinates & Shahshahani metric</p>
        </div>

        <div class="main-grid">
            <div>
                <canvas id="canvas" width="800" height="800"></canvas>
                <p style="font-size: 12px; color: #64748b; margin-top: 8px;">
                    Drag to rotate ‚Ä¢ Scroll to zoom ‚Ä¢ Click to set point
                </p>
            </div>

            <div>
                <div class="controls">
                    <h3>
                        Controls 
                        <span class="badge">GEOMETRIC</span>
                    </h3>
                    <div class="button-group">
                        <button class="play-btn" id="playBtn" onclick="togglePlay()">
                            <span id="playIcon">‚ñ∂</span>
                            <span id="playText">Play</span>
                        </button>
                        <button class="reset-btn" onclick="reset()">‚Üª</button>
                    </div>

                    <div style="margin-bottom: 16px;">
                        <label for="gameType">Game Type</label>
                        <select id="gameType" onchange="changeGameType()">
                            <option value="symmetric">Symmetric (Pure Gradient)</option>
                            <option value="hierarchy">Hierarchical</option>
                            <option value="rock-paper-scissors-lizard">RPSL (Pure Hamiltonian)</option>
                            <option value="mixed">Mixed Flow</option>
                        </select>
                    </div>

                    <div class="mode-selector">
                        <button class="mode-btn active" onclick="setCoordinateMode('log')">
                            Log-Ratio Coords
                        </button>
                        <button class="mode-btn" onclick="setCoordinateMode('barycentric')">
                            Standard Coords
                        </button>
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="showDecomposition" checked onchange="draw()">
                        <label for="showDecomposition">Show gradient/Hamiltonian split</label>
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="showVectorField" onchange="draw()">
                        <label for="showVectorField">Show vector field</label>
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="colorByMetric" checked onchange="draw()">
                        <label for="colorByMetric">Color by metric speed</label>
                    </div>

                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Speed</span>
                            <span id="speedValue">1.0√ó</span>
                        </div>
                        <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1" 
                               oninput="updateSpeed()">
                    </div>
                </div>

                <div class="geometric-info">
                    <h3>Geometric Data</h3>
                    <div class="metric-row">
                        <span>Shahshahani Speed:</span>
                        <span id="metricSpeed">0.0000</span>
                    </div>
                    <div class="metric-row">
                        <span>Metric Distance:</span>
                        <span id="metricDistance">0.000</span>
                    </div>
                    <div class="metric-row">
                        <span>Mean Fitness (H_S):</span>
                        <span id="potential">0.0000</span>
                    </div>
                    <div class="metric-row">
                        <span>Boundary Distance:</span>
                        <span id="boundaryDist">0.000</span>
                    </div>
                    <div class="decomp-viz">
                        <div>
                            <div style="font-size: 11px; margin-bottom: 4px;">Gradient</div>
                            <div class="decomp-bar">
                                <div class="decomp-fill gradient-fill" id="gradBar" style="width: 0%"></div>
                            </div>
                        </div>
                        <div>
                            <div style="font-size: 11px; margin-bottom: 4px;">Hamiltonian</div>
                            <div class="decomp-bar">
                                <div class="decomp-fill hamiltonian-fill" id="hamBar" style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="state-box">
                    <h3>Current State</h3>
                    <div class="state-row" id="row1">
                        <span>Strategy 1:</span>
                        <span id="x1">0.250</span>
                    </div>
                    <div class="state-row" id="row2">
                        <span>Strategy 2:</span>
                        <span id="x2">0.250</span>
                    </div>
                    <div class="state-row" id="row3">
                        <span>Strategy 3:</span>
                        <span id="x3">0.250</span>
                    </div>
                    <div class="state-row" id="row4">
                        <span>Strategy 4:</span>
                        <span id="x4">0.250</span>
                    </div>
                    <div class="coord-display" id="logCoords">
                        Log-ratio: u‚ÇÅ=0.000, u‚ÇÇ=0.000, u‚ÇÉ=0.000
                    </div>
                    <div style="padding-top: 12px; margin-top: 12px; border-top: 1px solid #cbd5e1;">
                        <div class="state-row">
                            <span>Active Dimension:</span>
                            <span id="dimension">3</span>
                        </div>
                    </div>
                </div>

                <div class="info-box">
                    <p>üìê Geometric Features:</p>
                    <p>‚Ä¢ Log-ratio coordinates u_i = log(x_i/x_n) naturally handle boundaries<br>
                    ‚Ä¢ Shahshahani metric g = Œ£(Œæ¬≤/x_i) measures evolutionary distance<br>
                    ‚Ä¢ Gradient/Hamiltonian decomposition: Symmetric ‚Üí gradient flow, Antisymmetric ‚Üí cyclic</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let isPlaying = false;
        let currentPoint = { x: 0.25, y: 0.25, z: 0.25, w: 0.25 };
        let trajectories = [];
        let geometricData = {
            metricDistance: 0,
            metricSpeed: 0,
            potential: 0,
            gradientMag: 0,
            hamiltonianMag: 0
        };
        let animationId = null;
        let gameType = 'symmetric';
        let speed = 1.0;
        let coordinateMode = 'log'; // 'log' or 'barycentric'
        
        // 3D rotation state
        let rotationX = -0.3;
        let rotationY = 0.5;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let zoom = 1.0;
        
        const EXTINCTION_THRESHOLD = 1e-8;
        
        const matrices = {
            symmetric: [
                [3, 1, 1, 1],
                [1, 3, 1, 1],
                [1, 1, 3, 1],
                [1, 1, 1, 3]
            ],
            hierarchy: [
                [4, 3, 2, 1],
                [1, 3, 2, 1],
                [1, 1, 2, 1],
                [1, 1, 1, 1]
            ],
            'rock-paper-scissors-lizard': [
                [0, 1, -1, 1],
                [-1, 0, 1, -1],
                [1, -1, 0, 1],
                [-1, 1, -1, 0]
            ],
            mixed: [
                [2, 1, 0, -1],
                [0, 2, 1, 0],
                [1, 0, 2, 1],
                [-1, 0, -1, 2]
            ]
        };
        
        // Tetrahedron vertices in 3D
        const vertices3D = [
            [1, 1, 1],
            [1, -1, -1],
            [-1, 1, -1],
            [-1, -1, 1]
        ];
        
        // Normalize vertices
        for (let v of vertices3D) {
            const len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
            v[0] /= len; v[1] /= len; v[2] /= len;
        }
        
        // ============= GEOMETRIC COORDINATE TRANSFORMATIONS =============
        
        function barycentricToLogRatio(x, y, z, w) {
            // Equation (2): ui = log(xi/xn)
            // Handle near-zero values
            const eps = 1e-10;
            return {
                u1: Math.log((x + eps) / (w + eps)),
                u2: Math.log((y + eps) / (w + eps)),
                u3: Math.log((z + eps) / (w + eps))
            };
        }
        
        function logRatioToBarycentric(u1, u2, u3) {
            // Equation (3): Softmax reconstruction
            const e1 = Math.exp(u1);
            const e2 = Math.exp(u2);
            const e3 = Math.exp(u3);
            const sum = 1 + e1 + e2 + e3;
            
            return {
                x: e1 / sum,
                y: e2 / sum,
                z: e3 / sum,
                w: 1 / sum
            };
        }
        
        // ============= SHAHSHAHANI METRIC =============
        
        function shahshahaniNorm(x, y, z, w, dx, dy, dz, dw) {
            // g_Shah(v,v) = Œ£(vi¬≤/xi)
            const eps = 1e-10;
            return Math.sqrt(
                dx*dx/(x + eps) + 
                dy*dy/(y + eps) + 
                dz*dz/(z + eps) + 
                dw*dw/(w + eps)
            );
        }
        
        function boundaryDistance(x, y, z, w) {
            // Minimum distance to any face in Shahshahani metric
            // Distance to face xi=0 is approximately sqrt(xi) in this metric
            const eps = 1e-10;
            return Math.min(
                Math.sqrt(x + eps),
                Math.sqrt(y + eps),
                Math.sqrt(z + eps),
                Math.sqrt(w + eps)
            );
        }
        
        // ============= MATRIX DECOMPOSITION =============
        
        function decomposeMatrix(A) {
            const n = A.length;
            const S = Array(n).fill(0).map(() => Array(n).fill(0));
            const K = Array(n).fill(0).map(() => Array(n).fill(0));
            
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    S[i][j] = (A[i][j] + A[j][i]) / 2;  // Symmetric
                    K[i][j] = (A[i][j] - A[j][i]) / 2;  // Antisymmetric
                }
            }
            
            return { S, K };
        }
        
        function shahshahaniPotential(state, S) {
            // H_S(x) = (1/2) x^T S x (Equation 12)
            const vec = [state.x, state.y, state.z, state.w];
            let potential = 0;
            
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    potential += 0.5 * S[i][j] * vec[i] * vec[j];
                }
            }
            
            return potential;
        }
        
        // ============= REPLICATOR DYNAMICS =============
        
        function computeFitness(state, A) {
            const {x, y, z, w} = state;
            return [
                A[0][0]*x + A[0][1]*y + A[0][2]*z + A[0][3]*w,
                A[1][0]*x + A[1][1]*y + A[1][2]*z + A[1][3]*w,
                A[2][0]*x + A[2][1]*y + A[2][2]*z + A[2][3]*w,
                A[3][0]*x + A[3][1]*y + A[3][2]*z + A[3][3]*w
            ];
        }
        
        function replicatorVelocity(state, A) {
            const {x, y, z, w} = state;
            const fitness = computeFitness(state, A);
            const avgFitness = x*fitness[0] + y*fitness[1] + z*fitness[2] + w*fitness[3];
            
            return {
                dx: x * (fitness[0] - avgFitness),
                dy: y * (fitness[1] - avgFitness),
                dz: z * (fitness[2] - avgFitness),
                dw: w * (fitness[3] - avgFitness)
            };
        }
        
        function replicatorStepLogCoordinates(state, dt) {
            // Work in log-ratio coordinates (Equation 4)
            let {x, y, z, w} = state;
            
            // Normalize
            const sum = x + y + z + w;
            x /= sum; y /= sum; z /= sum; w /= sum;
            
            // Convert to log-ratio
            const logRatio = barycentricToLogRatio(x, y, z, w);
            
            // Compute fitness in barycentric
            const A = matrices[gameType];
            const fitness = computeFitness({x, y, z, w}, A);
            
            // Flow in log coordinates: uÃái = fi - fn (Equation 4)
            const du1 = (fitness[0] - fitness[3]) * dt;
            const du2 = (fitness[1] - fitness[3]) * dt;
            const du3 = (fitness[2] - fitness[3]) * dt;
            
            // Update log coordinates
            const newLogRatio = {
                u1: logRatio.u1 + du1,
                u2: logRatio.u2 + du2,
                u3: logRatio.u3 + du3
            };
            
            // Convert back to barycentric
            return logRatioToBarycentric(newLogRatio.u1, newLogRatio.u2, newLogRatio.u3);
        }
        
        function replicatorStepBarycentric(state, dt) {
            // Standard barycentric integration
            let {x, y, z, w} = state;
            
            const sum = x + y + z + w;
            x /= sum; y /= sum; z /= sum; w /= sum;
            
            const A = matrices[gameType];
            const vel = replicatorVelocity({x, y, z, w}, A);
            
            let newX = x + vel.dx * dt;
            let newY = y + vel.dy * dt;
            let newZ = z + vel.dz * dt;
            let newW = w + vel.dw * dt;
            
            // Clamp
            newX = Math.max(0, newX);
            newY = Math.max(0, newY);
            newZ = Math.max(0, newZ);
            newW = Math.max(0, newW);
            
            const newSum = newX + newY + newZ + newW;
            if (newSum > 0) {
                return {
                    x: newX / newSum,
                    y: newY / newSum,
                    z: newZ / newSum,
                    w: newW / newSum
                };
            }
            return {x, y, z, w};
        }
        
        function replicatorStep(state, dt) {
            if (coordinateMode === 'log') {
                return replicatorStepLogCoordinates(state, dt);
            } else {
                return replicatorStepBarycentric(state, dt);
            }
        }
        
        // ============= GEOMETRIC DATA COMPUTATION =============
        
        function updateGeometricData(state, newState, dt) {
            const A = matrices[gameType];
            const {S, K} = decomposeMatrix(A);
            
            // Compute velocities
            const vel = replicatorVelocity(state, A);
            const velGrad = replicatorVelocity(state, S);
            const velHam = replicatorVelocity(state, K);
            
            // Shahshahani metric speed
            const metricSpeed = shahshahaniNorm(
                state.x, state.y, state.z, state.w,
                vel.dx, vel.dy, vel.dz, vel.dw
            );
            
            geometricData.metricSpeed = metricSpeed;
            geometricData.metricDistance += metricSpeed * dt;
            
            // Potential
            geometricData.potential = shahshahaniPotential(state, S);
            
            // Decomposition magnitudes
            geometricData.gradientMag = shahshahaniNorm(
                state.x, state.y, state.z, state.w,
                velGrad.dx, velGrad.dy, velGrad.dz, velGrad.dw
            );
            
            geometricData.hamiltonianMag = shahshahaniNorm(
                state.x, state.y, state.z, state.w,
                velHam.dx, velHam.dy, velHam.dz, velHam.dw
            );
            
            geometricData.boundaryDist = boundaryDistance(state.x, state.y, state.z, state.w);
        }
        
        // ============= 3D PROJECTION =============
        
        function rotate3D(point, rx, ry) {
            let [x, y, z] = point;
            
            let y1 = y * Math.cos(rx) - z * Math.sin(rx);
            let z1 = y * Math.sin(rx) + z * Math.cos(rx);
            
            let x2 = x * Math.cos(ry) + z1 * Math.sin(ry);
            let z2 = -x * Math.sin(ry) + z1 * Math.cos(ry);
            
            return [x2, y1, z2];
        }
        
        function project3D(point) {
            const [x, y, z] = rotate3D(point, rotationX, rotationY);
            const scale = 220 * zoom;
            const perspective = 3;
            const factor = perspective / (perspective + z);
            
            return {
                x: canvas.width / 2 + x * scale * factor,
                y: canvas.height / 2 - y * scale * factor
            };
        }
        
        function baryTo3D(x, y, z, w) {
            return [
                x * vertices3D[0][0] + y * vertices3D[1][0] + z * vertices3D[2][0] + w * vertices3D[3][0],
                x * vertices3D[0][1] + y * vertices3D[1][1] + z * vertices3D[2][1] + w * vertices3D[3][1],
                x * vertices3D[0][2] + y * vertices3D[1][2] + z * vertices3D[2][2] + w * vertices3D[3][2]
            ];
        }
        
        // ============= VISUALIZATION =============
        
        function getMetricColorGradient(speed) {
            // Color based on Shahshahani metric speed
            const maxSpeed = 2.0;
            const normalized = Math.min(speed / maxSpeed, 1);
            
            // Blue (slow) -> Green -> Yellow -> Red (fast)
            if (normalized < 0.33) {
                const t = normalized / 0.33;
                return `rgb(${Math.floor(66 * t)}, ${Math.floor(153 + 102*t)}, ${Math.floor(255 - 100*t)})`;
            } else if (normalized < 0.66) {
                const t = (normalized - 0.33) / 0.33;
                return `rgb(${Math.floor(66 + 168*t)}, ${Math.floor(255)}, ${Math.floor(155 - 155*t)})`;
            } else {
                const t = (normalized - 0.66) / 0.34;
                return `rgb(${Math.floor(234 + 21*t)}, ${Math.floor(255 - 107*t)}, 0)`;
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const showDecomp = document.getElementById('showDecomposition').checked;
            const showVectorField = document.getElementById('showVectorField').checked;
            const colorByMetric = document.getElementById('colorByMetric').checked;
            
            // Draw tetrahedron
            const projVerts = vertices3D.map(v => project3D(v));
            
            // Draw faces
            const faces = [
                [0, 1, 2], [0, 1, 3], [0, 2, 3], [1, 2, 3]
            ];
            
            ctx.fillStyle = 'rgba(200, 220, 240, 0.2)';
            faces.forEach(face => {
                ctx.beginPath();
                ctx.moveTo(projVerts[face[0]].x, projVerts[face[0]].y);
                ctx.lineTo(projVerts[face[1]].x, projVerts[face[1]].y);
                ctx.lineTo(projVerts[face[2]].x, projVerts[face[2]].y);
                ctx.closePath();
                ctx.fill();
            });
            
            // Draw edges
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 2;
            const edges = [
                [0, 1], [0, 2], [0, 3], [1, 2], [1, 3], [2, 3]
            ];
            
            edges.forEach(edge => {
                ctx.beginPath();
                ctx.moveTo(projVerts[edge[0]].x, projVerts[edge[0]].y);
                ctx.lineTo(projVerts[edge[1]].x, projVerts[edge[1]].y);
                ctx.stroke();
            });
            
            // Draw vertex labels
            ctx.fillStyle = '#1e293b';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ['S1', 'S2', 'S3', 'S4'].forEach((label, i) => {
                const offset = 25;
                const v = projVerts[i];
                const dir = rotate3D(vertices3D[i], rotationX, rotationY);
                ctx.fillText(label, v.x + dir[0] * offset, v.y - dir[1] * offset);
            });
            
            // Draw vector field
            if (showVectorField) {
                const A = matrices[gameType];
                const {S, K} = decomposeMatrix(A);
                
                ctx.lineWidth = 1.5;
                
                const gridSize = 3;
                for (let i = 0; i <= gridSize; i++) {
                    for (let j = 0; j <= gridSize-i; j++) {
                        for (let k = 0; k <= gridSize-i-j; k++) {
                            const l = gridSize-i-j-k;
                            if (l < 0) continue;
                            
                            const x = i/gridSize, y = j/gridSize, z = k/gridSize, w = l/gridSize;
                            if (x < 0.05 && y < 0.05 && z < 0.05 && w < 0.05) continue;
                            
                            const pos3D = baryTo3D(x, y, z, w);
                            const pos = project3D(pos3D);
                            
                            const vel = replicatorVelocity({x, y, z, w}, A);
                            const velGrad = showDecomp ? replicatorVelocity({x, y, z, w}, S) : vel;
                            const velHam = showDecomp ? replicatorVelocity({x, y, z, w}, K) : null;
                            
                            const dt = 0.15;
                            
                            // Draw gradient component (green)
                            if (showDecomp) {
                                const nextGrad = {
                                    x: x + velGrad.dx * dt,
                                    y: y + velGrad.dy * dt,
                                    z: z + velGrad.dz * dt,
                                    w: w + velGrad.dw * dt
                                };
                                const sum = nextGrad.x + nextGrad.y + nextGrad.z + nextGrad.w;
                                nextGrad.x /= sum; nextGrad.y /= sum; nextGrad.z /= sum; nextGrad.w /= sum;
                                
                                const next3D = baryTo3D(nextGrad.x, nextGrad.y, nextGrad.z, nextGrad.w);
                                const nextPos = project3D(next3D);
                                
                                ctx.strokeStyle = 'rgba(34, 197, 94, 0.6)';
                                const dx = nextPos.x - pos.x;
                                const dy = nextPos.y - pos.y;
                                const len = Math.sqrt(dx*dx + dy*dy);
                                
                                if (len > 0.5) {
                                    ctx.beginPath();
                                    ctx.moveTo(pos.x, pos.y);
                                    const scale = Math.min(len, 12) / len;
                                    ctx.lineTo(pos.x + dx*scale*0.8, pos.y + dy*scale*0.8);
                                    ctx.stroke();
                                }
                                
                                // Draw Hamiltonian component (blue)
                                const nextHam = {
                                    x: x + velHam.dx * dt,
                                    y: y + velHam.dy * dt,
                                    z: z + velHam.dz * dt,
                                    w: w + velHam.dw * dt
                                };
                                const sumH = nextHam.x + nextHam.y + nextHam.z + nextHam.w;
                                nextHam.x /= sumH; nextHam.y /= sumH; nextHam.z /= sumH; nextHam.w /= sumH;
                                
                                const next3DH = baryTo3D(nextHam.x, nextHam.y, nextHam.z, nextHam.w);
                                const nextPosH = project3D(next3DH);
                                
                                ctx.strokeStyle = 'rgba(59, 130, 246, 0.6)';
                                const dxH = nextPosH.x - pos.x;
                                const dyH = nextPosH.y - pos.y;
                                const lenH = Math.sqrt(dxH*dxH + dyH*dyH);
                                
                                if (lenH > 0.5) {
                                    ctx.beginPath();
                                    ctx.moveTo(pos.x, pos.y);
                                    const scaleH = Math.min(lenH, 12) / lenH;
                                    ctx.lineTo(pos.x + dxH*scaleH*0.8, pos.y + dyH*scaleH*0.8);
                                    ctx.stroke();
                                }
                            } else {
                                // Draw total flow
                                const next = {
                                    x: x + vel.dx * dt,
                                    y: y + vel.dy * dt,
                                    z: z + vel.dz * dt,
                                    w: w + vel.dw * dt
                                };
                                const sum = next.x + next.y + next.z + next.w;
                                next.x /= sum; next.y /= sum; next.z /= sum; next.w /= sum;
                                
                                const next3D = baryTo3D(next.x, next.y, next.z, next.w);
                                const nextPos = project3D(next3D);
                                
                                ctx.strokeStyle = 'rgba(100, 116, 139, 0.6)';
                                const dx = nextPos.x - pos.x;
                                const dy = nextPos.y - pos.y;
                                const len = Math.sqrt(dx*dx + dy*dy);
                                
                                if (len > 0.5) {
                                    ctx.beginPath();
                                    ctx.moveTo(pos.x, pos.y);
                                    const scale = Math.min(len, 12) / len;
                                    ctx.lineTo(pos.x + dx*scale*0.8, pos.y + dy*scale*0.8);
                                    ctx.stroke();
                                }
                            }
                        }
                    }
                }
            }
            
            // Draw trajectories
            trajectories.forEach((traj, idx) => {
                if (traj.length < 2) return;
                
                for (let i = 1; i < traj.length; i++) {
                    const prev = traj[i-1];
                    const curr = traj[i];
                    
                    const pos3DPrev = baryTo3D(prev.x, prev.y, prev.z, prev.w);
                    const pos3DCurr = baryTo3D(curr.x, curr.y, curr.z, curr.w);
                    const posPrev = project3D(pos3DPrev);
                    const posCurr = project3D(pos3DCurr);
                    
                    if (colorByMetric && curr.metricSpeed !== undefined) {
                        ctx.strokeStyle = getMetricColorGradient(curr.metricSpeed);
                    } else {
                        ctx.strokeStyle = `hsl(${idx * 60}, 70%, 50%)`;
                    }
                    
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.moveTo(posPrev.x, posPrev.y);
                    ctx.lineTo(posCurr.x, posCurr.y);
                    ctx.stroke();
                }
            });
            
            // Draw current point
            const pos3D = baryTo3D(currentPoint.x, currentPoint.y, currentPoint.z, currentPoint.w);
            const pos = project3D(pos3D);
            
            // Draw decomposition arrows from current point
            if (showDecomp && isPlaying) {
                const A = matrices[gameType];
                const {S, K} = decomposeMatrix(A);
                
                const velGrad = replicatorVelocity(currentPoint, S);
                const velHam = replicatorVelocity(currentPoint, K);
                
                const scale = 40;
                
                // Gradient arrow (green)
                ctx.strokeStyle = '#22c55e';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                
                const nextGrad = {
                    x: currentPoint.x + velGrad.dx * 0.3,
                    y: currentPoint.y + velGrad.dy * 0.3,
                    z: currentPoint.z + velGrad.dz * 0.3,
                    w: currentPoint.w + velGrad.dw * 0.3
                };
                const sumG = nextGrad.x + nextGrad.y + nextGrad.z + nextGrad.w;
                nextGrad.x /= sumG; nextGrad.y /= sumG; nextGrad.z /= sumG; nextGrad.w /= sumG;
                
                const grad3D = baryTo3D(nextGrad.x, nextGrad.y, nextGrad.z, nextGrad.w);
                const gradPos = project3D(grad3D);
                
                ctx.lineTo(gradPos.x, gradPos.y);
                ctx.stroke();
                
                // Arrow head
                const angleG = Math.atan2(gradPos.y - pos.y, gradPos.x - pos.x);
                ctx.beginPath();
                ctx.moveTo(gradPos.x, gradPos.y);
                ctx.lineTo(gradPos.x - 8*Math.cos(angleG-0.3), gradPos.y - 8*Math.sin(angleG-0.3));
                ctx.lineTo(gradPos.x - 8*Math.cos(angleG+0.3), gradPos.y - 8*Math.sin(angleG+0.3));
                ctx.closePath();
                ctx.fillStyle = '#22c55e';
                ctx.fill();
                
                // Hamiltonian arrow (blue)
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                
                const nextHam = {
                    x: currentPoint.x + velHam.dx * 0.3,
                    y: currentPoint.y + velHam.dy * 0.3,
                    z: currentPoint.z + velHam.dz * 0.3,
                    w: currentPoint.w + velHam.dw * 0.3
                };
                const sumH = nextHam.x + nextHam.y + nextHam.z + nextHam.w;
                nextHam.x /= sumH; nextHam.y /= sumH; nextHam.z /= sumH; nextHam.w /= sumH;
                
                const ham3D = baryTo3D(nextHam.x, nextHam.y, nextHam.z, nextHam.w);
                const hamPos = project3D(ham3D);
                
                ctx.lineTo(hamPos.x, hamPos.y);
                ctx.stroke();
                
                // Arrow head
                const angleH = Math.atan2(hamPos.y - pos.y, hamPos.x - pos.x);
                ctx.beginPath();
                ctx.moveTo(hamPos.x, hamPos.y);
                ctx.lineTo(hamPos.x - 8*Math.cos(angleH-0.3), hamPos.y - 8*Math.sin(angleH-0.3));
                ctx.lineTo(hamPos.x - 8*Math.cos(angleH+0.3), hamPos.y - 8*Math.sin(angleH+0.3));
                ctx.closePath();
                ctx.fillStyle = '#3b82f6';
                ctx.fill();
            }
            
            // Draw current point marker
            ctx.fillStyle = '#ef4444';
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 9, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();
        }
        
        // ============= ANIMATION =============
        
        function animate() {
            const dt = 0.04 * speed;
            
            const oldState = { ...currentPoint };
            const newState = replicatorStep(currentPoint, dt);
            
            currentPoint = newState;
            
            // Update geometric data
            updateGeometricData(oldState, newState, dt);
            updateDisplay();
            
            // Store in trajectory with metric data
            if (trajectories.length === 0) {
                trajectories.push([]);
            }
            
            const lastTraj = trajectories[trajectories.length - 1];
            lastTraj.push({ 
                ...currentPoint,
                metricSpeed: geometricData.metricSpeed
            });
            
            if (lastTraj.length > 500) lastTraj.shift();
            
            draw();
            
            if (isPlaying) {
                animationId = requestAnimationFrame(animate);
            }
        }
        
        // ============= UI FUNCTIONS =============
        
        function togglePlay() {
            isPlaying = !isPlaying;
            const playBtn = document.getElementById('playBtn');
            const playIcon = document.getElementById('playIcon');
            const playText = document.getElementById('playText');
            
            if (isPlaying) {
                playBtn.classList.add('playing');
                playIcon.textContent = '‚è∏';
                playText.textContent = 'Pause';
                if (trajectories.length === 0) {
                    trajectories.push([]);
                }
                requestAnimationFrame(animate);
            } else {
                playBtn.classList.remove('playing');
                playIcon.textContent = '‚ñ∂';
                playText.textContent = 'Play';
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
            }
        }
        
        function reset() {
            isPlaying = false;
            const playBtn = document.getElementById('playBtn');
            playBtn.classList.remove('playing');
            document.getElementById('playIcon').textContent = '‚ñ∂';
            document.getElementById('playText').textContent = 'Play';
            
            if (animationId) cancelAnimationFrame(animationId);
            
            currentPoint = { x: 0.25, y: 0.25, z: 0.25, w: 0.25 };
            trajectories = [];
            geometricData = {
                metricDistance: 0,
                metricSpeed: 0,
                potential: 0,
                gradientMag: 0,
                hamiltonianMag: 0
            };
            updateDisplay();
            draw();
        }
        
        function changeGameType() {
            gameType = document.getElementById('gameType').value;
            reset();
        }
        
        function updateSpeed() {
            speed = parseFloat(document.getElementById('speed').value);
            document.getElementById('speedValue').textContent = speed.toFixed(1) + '√ó';
        }
        
        function setCoordinateMode(mode) {
            coordinateMode = mode;
            
            // Update button styles
            const buttons = document.querySelectorAll('.mode-btn');
            buttons.forEach(btn => {
                if ((mode === 'log' && btn.textContent.includes('Log-Ratio')) ||
                    (mode === 'barycentric' && btn.textContent.includes('Standard'))) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            updateDisplay();
        }
        
        function updateDisplay() {
            const format = (x) => x.toFixed(3);
            
            document.getElementById('x1').textContent = format(currentPoint.x);
            document.getElementById('x2').textContent = format(currentPoint.y);
            document.getElementById('x3').textContent = format(currentPoint.z);
            document.getElementById('x4').textContent = format(currentPoint.w);
            
            // Show log-ratio coordinates
            const logRatio = barycentricToLogRatio(
                currentPoint.x, currentPoint.y, currentPoint.z, currentPoint.w
            );
            document.getElementById('logCoords').textContent = 
                `Log-ratio: u‚ÇÅ=${logRatio.u1.toFixed(3)}, u‚ÇÇ=${logRatio.u2.toFixed(3)}, u‚ÇÉ=${logRatio.u3.toFixed(3)}`;
            
            // Mark extinct strategies
            const rows = ['row1', 'row2', 'row3', 'row4'];
            const vals = [currentPoint.x, currentPoint.y, currentPoint.z, currentPoint.w];
            rows.forEach((row, i) => {
                if (vals[i] < 0.01) {
                    document.getElementById(row).classList.add('extinct');
                } else {
                    document.getElementById(row).classList.remove('extinct');
                }
            });
            
            // Update geometric data display
            document.getElementById('metricSpeed').textContent = geometricData.metricSpeed.toFixed(4);
            document.getElementById('metricDistance').textContent = geometricData.metricDistance.toFixed(3);
            document.getElementById('potential').textContent = geometricData.potential.toFixed(4);
            document.getElementById('boundaryDist').textContent = geometricData.boundaryDist.toFixed(3);
            
            // Update decomposition bars
            const totalMag = geometricData.gradientMag + geometricData.hamiltonianMag + 0.001;
            const gradPct = (geometricData.gradientMag / totalMag) * 100;
            const hamPct = (geometricData.hamiltonianMag / totalMag) * 100;
            
            document.getElementById('gradBar').style.width = gradPct + '%';
            document.getElementById('hamBar').style.width = hamPct + '%';
            
            // Calculate active dimension
            let activeDim = 0;
            if (currentPoint.x >= 0.01) activeDim++;
            if (currentPoint.y >= 0.01) activeDim++;
            if (currentPoint.z >= 0.01) activeDim++;
            if (currentPoint.w >= 0.01) activeDim++;
            document.getElementById('dimension').textContent = activeDim - 1;
        }
        
        // ============= MOUSE INTERACTION =============
        
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const startX = e.clientX;
            const startY = e.clientY;
            const startTime = Date.now();
            
            isDragging = true;
            lastMouseX = startX;
            lastMouseY = startY;
            
            const mouseUpHandler = (upEvent) => {
                const endX = upEvent.clientX;
                const endY = upEvent.clientY;
                const endTime = Date.now();
                const dist = Math.sqrt((endX-startX)**2 + (endY-startY)**2);
                const duration = endTime - startTime;
                
                isDragging = false;
                
                if (dist < 5 && duration < 200) {
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const mouseX = (upEvent.clientX - rect.left) * scaleX;
                    const mouseY = (upEvent.clientY - rect.top) * scaleY;
                    setPointFromClick(mouseX, mouseY);
                }
                
                canvas.removeEventListener('mouseup', mouseUpHandler);
            };
            
            canvas.addEventListener('mouseup', mouseUpHandler);
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                
                rotationY += dx * 0.01;
                rotationX += dy * 0.01;
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                
                draw();
            }
        });
        
        document.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            zoom *= (1 - e.deltaY * 0.001);
            zoom = Math.max(0.3, Math.min(3, zoom));
            draw();
        });
        
        function setPointFromClick(mouseX, mouseY) {
            let bestDist = Infinity;
            let bestPoint = null;
            
            const gridSize = 15;
            for (let i = 0; i <= gridSize; i++) {
                for (let j = 0; j <= gridSize-i; j++) {
                    for (let k = 0; k <= gridSize-i-j; k++) {
                        const l = gridSize-i-j-k;
                        if (l < 0) continue;
                        
                        const x = i/gridSize, y = j/gridSize, z = k/gridSize, w = l/gridSize;
                        
                        const pos3D = baryTo3D(x, y, z, w);
                        const proj = project3D(pos3D);
                        
                        const dist = Math.sqrt((proj.x - mouseX)**2 + (proj.y - mouseY)**2);
                        
                        if (dist < bestDist) {
                            bestDist = dist;
                            bestPoint = { x, y, z, w };
                        }
                    }
                }
            }
            
            if (bestPoint && bestDist < 150) {
                currentPoint = { ...bestPoint };
                trajectories.push([]);
                geometricData.metricDistance = 0;
                updateDisplay();
                draw();
            }
        }
        
        // ============= INITIALIZATION =============
        
        updateDisplay();
        draw();
    </script>
</body>
</html>