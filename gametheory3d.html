<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Replicator Dynamics - Information Geometry</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(to bottom right, #f8fafc, #e2e8f0);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            padding: 24px;
        }
        
        .header {
            margin-bottom: 20px;
        }
        
        .header h1 {
            font-size: 24px;
            color: #1e293b;
            margin-bottom: 4px;
        }
        
        .header p {
            font-size: 14px;
            color: #64748b;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 24px;
        }
        
        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
        
        canvas {
            width: 100%;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: #fafafa;
            cursor: move;
        }

        #histogramCanvas {
            cursor: default;
            height: 200px !important;
        }
        
        .controls {
            background: #f8fafc;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
        }
        
        .controls h3 {
            font-size: 16px;
            color: #1e293b;
            margin-bottom: 12px;
        }
        
        .button-group {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }
        
        button {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
        }
        
        .play-btn {
            flex: 1;
            background: #22c55e;
            color: white;
        }
        
        .play-btn:hover {
            background: #16a34a;
        }
        
        .play-btn.playing {
            background: #ef4444;
        }
        
        .play-btn.playing:hover {
            background: #dc2626;
        }
        
        .reset-btn {
            padding: 10px 16px;
            background: #e2e8f0;
            color: #475569;
        }
        
        .reset-btn:hover {
            background: #cbd5e1;
        }
        
        label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: #1e293b;
            margin-bottom: 8px;
        }
        
        select, input[type="range"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            font-size: 14px;
        }
        
        .slider-group {
            margin-bottom: 12px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 13px;
        }
        
        input[type="range"] {
            padding: 0;
            height: 6px;
        }
        
        .state-box {
            background: #f8fafc;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
        }
        
        .state-box h3 {
            font-size: 16px;
            color: #1e293b;
            margin-bottom: 12px;
        }
        
        .state-row {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            margin-bottom: 8px;
        }
        
        .state-row span:first-child {
            color: #64748b;
        }
        
        .state-row span:last-child {
            font-family: 'Courier New', monospace;
        }
        
        .extinct {
            opacity: 0.4;
            text-decoration: line-through;
        }
        
        .info-box {
            background: #dbeafe;
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            color: #1e3a8a;
            margin-bottom: 12px;
            border: 1px solid #93c5fd;
        }
        
        .info-box p:first-child {
            font-weight: 600;
            margin-bottom: 4px;
            color: #1e3a8a;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
        }

        .checkbox-group label {
            margin: 0;
            font-weight: normal;
        }

        .histogram-box {
            background: #f8fafc;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .histogram-box h3 {
            font-size: 16px;
            color: #1e293b;
            margin-bottom: 12px;
        }

        .geometry-box {
            background: #fef3c7;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            border: 2px solid #fbbf24;
        }

        .geometry-box h3 {
            font-size: 16px;
            color: #92400e;
            margin-bottom: 12px;
        }

        .metric-display {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            background: white;
            padding: 8px;
            border-radius: 4px;
            margin-top: 8px;
            max-height: 150px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Replicator Dynamics - Information Geometry View</h1>
            <p>Fisher metric, geodesics, and gradient flow on the probability simplex</p>
        </div>

        <div class="main-grid">
            <div>
                <canvas id="canvas" width="700" height="700"></canvas>
                <p style="font-size: 12px; color: #64748b; margin-top: 8px;">
                    Drag to rotate • Scroll to zoom
                </p>
            </div>

            <div>
                <div class="controls">
                    <h3>Controls</h3>
                    <div class="button-group">
                        <button class="play-btn" id="playBtn" onclick="togglePlay()">
                            <span id="playIcon">▶</span>
                            <span id="playText">Play</span>
                        </button>
                        <button class="reset-btn" onclick="reset()">Reset</button>
                    </div>

                    <button class="reset-btn" onclick="setInteriorPoint()" style="width: 100%; margin-bottom: 16px;">
                        Random Interior Point
                    </button>

                    <label for="gameType">Game Type</label>
                    <select id="gameType" onchange="changeGameType()">
                        <option value="cyclic">Cyclic (Rock-Paper-Scissors-Lizard)</option>
                        <option value="coordination">Coordination Game</option>
                        <option value="prisoner">Prisoner's Dilemma</option>
                        <option value="mixed">Mixed Dynamics</option>
                    </select>

                    <div class="slider-group" style="margin-top: 16px;">
                        <div class="slider-label">
                            <span>Animation Speed</span>
                            <span id="speedValue">1.0×</span>
                        </div>
                        <input type="range" id="speed" min="0.1" max="5" step="0.1" value="1" oninput="updateSpeed()">
                    </div>

                    <label for="tailLength" style="margin-top: 16px;">Trajectory Tail Length</label>
                    <select id="tailLength" onchange="updateTailLength()">
                        <option value="50">Short (50 points)</option>
                        <option value="150">Medium (150 points)</option>
                        <option value="300" selected>Long (300 points)</option>
                        <option value="500">Very Long (500 points)</option>
                        <option value="-1">Keep All</option>
                    </select>

                    <div class="checkbox-group" style="margin-top: 16px;">
                        <input type="checkbox" id="showFlow" checked onchange="draw()">
                        <label for="showFlow">Show flow field</label>
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="showTrajectory" checked onchange="draw()">
                        <label for="showTrajectory">Show trajectory</label>
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="showMetricEllipses" onchange="draw()">
                        <label for="showMetricEllipses">Show Fisher metric grid</label>
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="showCurrentMetric" checked onchange="draw()">
                        <label for="showCurrentMetric">Show metric at current point</label>
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="showGeodesic" onchange="draw()">
                        <label for="showGeodesic">Show geodesic to center</label>
                    </div>
                </div>

                <div class="histogram-box">
                    <h3>Strategy Mixture</h3>
                    <canvas id="histogramCanvas" width="350" height="200"></canvas>
                </div>

                <div class="geometry-box">
                    <h3>⚡ Information Geometry</h3>
                    <div class="state-row">
                        <span>Shannon Entropy H(p):</span>
                        <span id="entropy">0.000</span>
                    </div>
                    <div class="state-row">
                        <span>KL Divergence from uniform:</span>
                        <span id="klDiv">0.000</span>
                    </div>
                    <div class="state-row">
                        <span>Fisher-Rao distance to center:</span>
                        <span id="fisherDist">0.000</span>
                    </div>
                    <div class="state-row" style="margin-top: 12px;">
                        <span style="font-weight: 600;">Coordinate View:</span>
                        <span></span>
                    </div>
                    <div class="state-row">
                        <input type="radio" name="coordSystem" value="barycentric" checked onchange="updateDisplay()">
                        <label style="margin: 0;">Barycentric (x,y,z,w)</label>
                    </div>
                    <div class="state-row">
                        <input type="radio" name="coordSystem" value="log" onchange="updateDisplay()">
                        <label style="margin: 0;">Log-ratio (centered)</label>
                    </div>
                    <div id="fisherMetricDisplay" class="metric-display">
                    </div>
                </div>

                <div class="state-box">
                    <h3>Current State <span id="coordModeLabel" style="font-size: 12px; color: #3b82f6; font-weight: normal;">(Barycentric)</span></h3>
                    <div class="state-row" id="row1">
                        <span id="label1">Strategy 1 (x):</span>
                        <span id="x1">0.250</span>
                    </div>
                    <div class="state-row" id="row2">
                        <span id="label2">Strategy 2 (y):</span>
                        <span id="x2">0.250</span>
                    </div>
                    <div class="state-row" id="row3">
                        <span id="label3">Strategy 3 (z):</span>
                        <span id="x3">0.250</span>
                    </div>
                    <div class="state-row" id="row4">
                        <span id="label4">Strategy 4 (w):</span>
                        <span id="x4">0.250</span>
                    </div>
                    <hr style="margin: 12px 0; border: none; border-top: 1px solid #e2e8f0;">
                    <div class="state-row">
                        <span>Avg Fitness:</span>
                        <span id="fitness">0.0000</span>
                    </div>
                    <div class="state-row">
                        <span>Active Dimension:</span>
                        <span id="dimension">3</span>
                    </div>
                </div>

                <div class="info-box">
                    <p>Information Geometry Features:</p>
                    The simplex is equipped with the Fisher information metric g_ij = δ_ij/p_i - 1. Replicator dynamics can be viewed as gradient flow.
                    <p style="margin-top: 8px;"><strong>Metric Visualizations:</strong></p>
                    <strong>Purple Grid Ellipses:</strong> Static grid showing overall metric structure across the simplex.<br>
                    <strong>Green Current Ellipse:</strong> DYNAMIC! Moves with the red point and grows/shrinks to show how the local metric changes. Watch it expand dramatically as the point approaches boundaries - this is the Fisher metric stretching space! At center it's small and uniform; near edges it grows large showing negative curvature.
                    <p style="margin-top: 8px;"><strong>Geodesics:</strong> The "straight lines" in this curved geometry, computed by interpolation in log-space.</p>
                    <p style="margin-top: 8px;"><strong>Coordinate Systems:</strong></p>
                    <strong>Barycentric:</strong> Standard probabilities (x,y,z,w) summing to 1.<br>
                    <strong>Log-Ratio:</strong> Centered log coordinates log(p_i/g) where g is geometric mean. These reveal the natural linear structure of compositional data and are centered at 0 for uniform distribution. Note: CLR coordinates sum to 0!
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const histCanvas = document.getElementById('histogramCanvas');
        const histCtx = histCanvas.getContext('2d');

        // State
        let currentPoint = { x: 0.25, y: 0.25, z: 0.25, w: 0.25 };
        let trajectories = [];
        let isPlaying = false;
        let animationId = null;
        let speed = 1.0;
        let gameType = 'cyclic';
        let tailLength = 300;
        
        // View control
        let rotationX = -0.3;
        let rotationY = 0.7;
        let zoom = 1.2;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        const EXTINCTION_THRESHOLD = 0.001;
        const LOG_MIN = 1e-10; // Minimum for log calculations
        
        // Game matrices
        const matrices = {
            cyclic: [
                [0, -1, 1, 0.5],
                [1, 0, -1, 0.5],
                [-1, 1, 0, -0.5],
                [-0.5, -0.5, 0.5, 0]
            ],
            coordination: [
                [2, 0, 0, 1],
                [0, 2, 1, 0],
                [0, 1, 2, 0],
                [1, 0, 0, 2]
            ],
            prisoner: [
                [3, 0, 2, 1],
                [5, 1, 3, 2],
                [2, 3, 3, 1],
                [1, 2, 1, 2]
            ],
            mixed: [
                [1, 2, -1, 0],
                [-1, 1, 2, 1],
                [2, -1, 1, -1],
                [0, 1, -1, 1]
            ]
        };
        
        // Tetrahedron vertices in 3D
        const v1 = { x: 0, y: 1, z: 0 };
        const v2 = { x: Math.cos(0), y: 0, z: Math.sin(0) };
        const v3 = { x: Math.cos(2*Math.PI/3), y: 0, z: Math.sin(2*Math.PI/3) };
        const v4 = { x: Math.cos(4*Math.PI/3), y: 0, z: Math.sin(4*Math.PI/3) };
        
        function baryTo3D(x, y, z, w) {
            return {
                x: x * v1.x + y * v2.x + z * v3.x + w * v4.x,
                y: x * v1.y + y * v2.y + z * v3.y + w * v4.y,
                z: x * v1.z + y * v2.z + z * v3.z + w * v4.z
            };
        }
        
        function rotate3D(p) {
            let x = p.x, y = p.y, z = p.z;
            
            let y1 = y * Math.cos(rotationX) - z * Math.sin(rotationX);
            let z1 = y * Math.sin(rotationX) + z * Math.cos(rotationX);
            
            let x2 = x * Math.cos(rotationY) + z1 * Math.sin(rotationY);
            let z2 = -x * Math.sin(rotationY) + z1 * Math.cos(rotationY);
            
            return { x: x2, y: y1, z: z2 };
        }
        
        function project3D(p) {
            const scale = 250 * zoom;
            const rotated = rotate3D(p);
            return {
                x: canvas.width/2 + rotated.x * scale,
                y: canvas.height/2 - rotated.y * scale,
                z: rotated.z
            };
        }

        // Information-geometric quantities
        function shannonEntropy(p) {
            const vals = [p.x, p.y, p.z, p.w];
            let H = 0;
            for (let val of vals) {
                if (val > LOG_MIN) {
                    H -= val * Math.log(val);
                }
            }
            return H;
        }

        function klDivergence(p, q) {
            // KL(p||q)
            const pVals = [p.x, p.y, p.z, p.w];
            const qVals = [q.x, q.y, q.z, q.w];
            let kl = 0;
            for (let i = 0; i < 4; i++) {
                if (pVals[i] > LOG_MIN && qVals[i] > LOG_MIN) {
                    kl += pVals[i] * Math.log(pVals[i] / qVals[i]);
                }
            }
            return kl;
        }

        function fisherRaoDistance(p, q) {
            // Approximate Fisher-Rao distance using sqrt of 2*KL divergence symmetrized
            const kl1 = klDivergence(p, q);
            const kl2 = klDivergence(q, p);
            return Math.sqrt(2 * (kl1 + kl2) / 2);
        }

        function centeredLogRatio(p) {
            // CLR transformation
            const vals = [p.x, p.y, p.z, p.w];
            const geomMean = Math.pow(
                vals.reduce((prod, v) => prod * Math.max(v, LOG_MIN), 1),
                1/4
            );
            return vals.map(v => Math.log(Math.max(v, LOG_MIN) / geomMean));
        }

        function fisherMetricMatrix(p) {
            // Fisher information metric: g_ij = δ_ij/p_i - 1
            // This is the 4x4 metric on the simplex
            const vals = [p.x, p.y, p.z, p.w];
            const g = [];
            for (let i = 0; i < 4; i++) {
                g[i] = [];
                for (let j = 0; j < 4; j++) {
                    if (i === j) {
                        g[i][j] = 1 / Math.max(vals[i], LOG_MIN) - 1;
                    } else {
                        g[i][j] = -1;
                    }
                }
            }
            return g;
        }
        
        function replicatorDynamics(p) {
            const A = matrices[gameType];
            
            const fitness = [
                A[0][0] * p.x + A[0][1] * p.y + A[0][2] * p.z + A[0][3] * p.w,
                A[1][0] * p.x + A[1][1] * p.y + A[1][2] * p.z + A[1][3] * p.w,
                A[2][0] * p.x + A[2][1] * p.y + A[2][2] * p.z + A[2][3] * p.w,
                A[3][0] * p.x + A[3][1] * p.y + A[3][2] * p.z + A[3][3] * p.w
            ];
            
            const avgFitness = p.x * fitness[0] + p.y * fitness[1] + 
                             p.z * fitness[2] + p.w * fitness[3];
            
            return {
                x: p.x * (fitness[0] - avgFitness),
                y: p.y * (fitness[1] - avgFitness),
                z: p.z * (fitness[2] - avgFitness),
                w: p.w * (fitness[3] - avgFitness)
            };
        }

        function computeGeodesicToCenter(p, numPoints = 50) {
            // Approximate geodesic from p to center using Fisher-Rao metric
            // This is a simplified computation - true geodesics require solving ODEs
            const center = { x: 0.25, y: 0.25, z: 0.25, w: 0.25 };
            const geodesic = [];
            
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                // Linear interpolation in log space (approximate geodesic)
                const pt = {
                    x: Math.exp((1-t)*Math.log(Math.max(p.x, LOG_MIN)) + t*Math.log(center.x)),
                    y: Math.exp((1-t)*Math.log(Math.max(p.y, LOG_MIN)) + t*Math.log(center.y)),
                    z: Math.exp((1-t)*Math.log(Math.max(p.z, LOG_MIN)) + t*Math.log(center.z)),
                    w: Math.exp((1-t)*Math.log(Math.max(p.w, LOG_MIN)) + t*Math.log(center.w))
                };
                // Renormalize
                const sum = pt.x + pt.y + pt.z + pt.w;
                pt.x /= sum;
                pt.y /= sum;
                pt.z /= sum;
                pt.w /= sum;
                geodesic.push(pt);
            }
            
            return geodesic;
        }

        function drawMetricEllipse(p, baseScale = 0.03) {
            // Draw an ellipse showing the Fisher metric at point p
            // The Fisher metric g_ij = δ_ij/p_i - 1 determines distances
            // Near boundaries (small p_i), distances are STRETCHED - ellipses get bigger
            
            const vals = [p.x, p.y, p.z, p.w];
            
            // Skip if too close to boundary (would be infinite)
            if (vals.some(v => v < 0.02)) return;
            
            // Compute metric scale factor: how much does the metric stretch space?
            // The metric has form g_ij = δ_ij/p_i - 1
            // Determinant grows as product of 1/p_i terms
            // For visualization: use harmonic mean as proxy for metric "size"
            const harmonicMean = 4 / (1/Math.max(p.x, 0.01) + 1/Math.max(p.y, 0.01) + 
                                      1/Math.max(p.z, 0.01) + 1/Math.max(p.w, 0.01));
            
            // Scale inversely with harmonic mean: smaller p_i → larger ellipse
            // At uniform (0.25,0.25,0.25,0.25): harmonicMean = 0.25, metricScale = 1
            // Near boundary: harmonicMean small, metricScale large
            const metricScale = 0.25 / Math.max(harmonicMean, 0.01);
            const adjustedScale = baseScale * Math.sqrt(metricScale);
            
            // Sample circle in tangent space
            const angles = 16;
            const points = [];
            
            for (let i = 0; i < angles; i++) {
                const theta = 2 * Math.PI * i / angles;
                
                // Create tangent vector in the 3D tangent space of simplex
                // These satisfy the constraint: sum(v_i) = 0
                const v = [
                    Math.cos(theta),
                    Math.sin(theta) * 0.7,
                    Math.sin(theta) * 0.3,
                    -(Math.cos(theta) + Math.sin(theta) * 0.7 + Math.sin(theta) * 0.3)
                ];
                
                // Apply metric: scale each component by sqrt(p_i) (inverse Fisher metric)
                // This makes ellipse larger in directions where p_i is smaller
                const scaled_v = [
                    v[0] * Math.sqrt(Math.max(p.x, 0.01)),
                    v[1] * Math.sqrt(Math.max(p.y, 0.01)),
                    v[2] * Math.sqrt(Math.max(p.z, 0.01)),
                    v[3] * Math.sqrt(Math.max(p.w, 0.01))
                ];
                
                // Move along geodesic
                const p_new = {
                    x: p.x + scaled_v[0] * adjustedScale,
                    y: p.y + scaled_v[1] * adjustedScale,
                    z: p.z + scaled_v[2] * adjustedScale,
                    w: p.w + scaled_v[3] * adjustedScale
                };
                
                // Project back to simplex
                if (p_new.x > 0 && p_new.y > 0 && p_new.z > 0 && p_new.w > 0) {
                    const sum = p_new.x + p_new.y + p_new.z + p_new.w;
                    points.push({
                        x: p_new.x / sum,
                        y: p_new.y / sum,
                        z: p_new.z / sum,
                        w: p_new.w / sum
                    });
                }
            }
            
            if (points.length < 3) return;
            
            // Draw the ellipse with color intensity based on metric scale
            const intensity = Math.min(1, metricScale / 3);
            ctx.strokeStyle = `rgba(168, 85, 247, ${0.4 + intensity * 0.4})`;
            ctx.lineWidth = 1.5 + intensity * 1.5;
            ctx.beginPath();
            const first3D = baryTo3D(points[0].x, points[0].y, points[0].z, points[0].w);
            const firstProj = project3D(first3D);
            ctx.moveTo(firstProj.x, firstProj.y);
            
            for (let i = 1; i < points.length; i++) {
                const p3d = baryTo3D(points[i].x, points[i].y, points[i].z, points[i].w);
                const proj = project3D(p3d);
                ctx.lineTo(proj.x, proj.y);
            }
            ctx.closePath();
            ctx.stroke();
        }

        function drawCurrentMetricEllipse(p, baseScale = 0.04) {
            // Draw a prominent, dynamic ellipse at the current point
            // This moves with the point and shows how local geometry changes!
            
            const vals = [p.x, p.y, p.z, p.w];
            if (vals.some(v => v < 0.02)) return;
            
            const harmonicMean = 4 / (1/Math.max(p.x, 0.01) + 1/Math.max(p.y, 0.01) + 
                                      1/Math.max(p.z, 0.01) + 1/Math.max(p.w, 0.01));
            const metricScale = 0.25 / Math.max(harmonicMean, 0.01);
            const adjustedScale = baseScale * Math.sqrt(metricScale);
            
            const angles = 24; // More points for smoother current ellipse
            const points = [];
            
            for (let i = 0; i < angles; i++) {
                const theta = 2 * Math.PI * i / angles;
                const v = [
                    Math.cos(theta),
                    Math.sin(theta) * 0.7,
                    Math.sin(theta) * 0.3,
                    -(Math.cos(theta) + Math.sin(theta) * 0.7 + Math.sin(theta) * 0.3)
                ];
                
                const scaled_v = [
                    v[0] * Math.sqrt(Math.max(p.x, 0.01)),
                    v[1] * Math.sqrt(Math.max(p.y, 0.01)),
                    v[2] * Math.sqrt(Math.max(p.z, 0.01)),
                    v[3] * Math.sqrt(Math.max(p.w, 0.01))
                ];
                
                const p_new = {
                    x: p.x + scaled_v[0] * adjustedScale,
                    y: p.y + scaled_v[1] * adjustedScale,
                    z: p.z + scaled_v[2] * adjustedScale,
                    w: p.w + scaled_v[3] * adjustedScale
                };
                
                if (p_new.x > 0 && p_new.y > 0 && p_new.z > 0 && p_new.w > 0) {
                    const sum = p_new.x + p_new.y + p_new.z + p_new.w;
                    points.push({
                        x: p_new.x / sum,
                        y: p_new.y / sum,
                        z: p_new.z / sum,
                        w: p_new.w / sum
                    });
                }
            }
            
            if (points.length < 3) return;
            
            // Draw with bright cyan/green color - stands out from the purple grid
            const intensity = Math.min(1, metricScale / 3);
            
            // Fill with semi-transparent color
            ctx.fillStyle = `rgba(34, 197, 94, ${0.15 + intensity * 0.1})`;
            ctx.beginPath();
            const first3D = baryTo3D(points[0].x, points[0].y, points[0].z, points[0].w);
            const firstProj = project3D(first3D);
            ctx.moveTo(firstProj.x, firstProj.y);
            
            for (let i = 1; i < points.length; i++) {
                const p3d = baryTo3D(points[i].x, points[i].y, points[i].z, points[i].w);
                const proj = project3D(p3d);
                ctx.lineTo(proj.x, proj.y);
            }
            ctx.closePath();
            ctx.fill();
            
            // Outline with bright green
            ctx.strokeStyle = `rgba(34, 197, 94, ${0.8 + intensity * 0.2})`;
            ctx.lineWidth = 3 + intensity * 1;
            ctx.beginPath();
            ctx.moveTo(firstProj.x, firstProj.y);
            for (let i = 1; i < points.length; i++) {
                const p3d = baryTo3D(points[i].x, points[i].y, points[i].z, points[i].w);
                const proj = project3D(p3d);
                ctx.lineTo(proj.x, proj.y);
            }
            ctx.closePath();
            ctx.stroke();
        }
        
        function drawHistogram() {
            const width = histCanvas.width;
            const height = histCanvas.height;
            const padding = 40;
            const barWidth = (width - 2 * padding) / 4;
            const maxHeight = height - 2 * padding;
            
            histCtx.clearRect(0, 0, width, height);
            
            const colors = [
                'rgba(255, 50, 50, 0.8)',
                'rgba(50, 255, 50, 0.8)',
                'rgba(50, 100, 255, 0.8)',
                'rgba(255, 200, 50, 0.8)'
            ];
            
            const values = [currentPoint.x, currentPoint.y, currentPoint.z, currentPoint.w];
            const labels = ['x', 'y', 'z', 'w'];
            
            // Draw axes
            histCtx.strokeStyle = '#cbd5e1';
            histCtx.lineWidth = 2;
            histCtx.beginPath();
            histCtx.moveTo(padding, padding);
            histCtx.lineTo(padding, height - padding);
            histCtx.lineTo(width - padding, height - padding);
            histCtx.stroke();
            
            // Draw grid lines
            histCtx.strokeStyle = '#e2e8f0';
            histCtx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = padding + (maxHeight * i / 5);
                histCtx.beginPath();
                histCtx.moveTo(padding, y);
                histCtx.lineTo(width - padding, y);
                histCtx.stroke();
                
                histCtx.fillStyle = '#64748b';
                histCtx.font = '11px sans-serif';
                histCtx.textAlign = 'right';
                histCtx.fillText((1 - i/5).toFixed(1), padding - 8, y + 4);
            }
            
            // Draw bars
            values.forEach((value, i) => {
                const x = padding + i * barWidth + barWidth * 0.1;
                const barH = value * maxHeight;
                const barY = height - padding - barH;
                
                histCtx.fillStyle = colors[i];
                histCtx.fillRect(x, barY, barWidth * 0.8, barH);
                
                histCtx.strokeStyle = colors[i].replace('0.8', '1');
                histCtx.lineWidth = 2;
                histCtx.strokeRect(x, barY, barWidth * 0.8, barH);
                
                if (value > 0.02) {
                    histCtx.fillStyle = '#1e293b';
                    histCtx.font = 'bold 11px sans-serif';
                    histCtx.textAlign = 'center';
                    histCtx.fillText(value.toFixed(3), x + barWidth * 0.4, barY - 6);
                }
                
                histCtx.fillStyle = '#1e293b';
                histCtx.font = 'bold 14px sans-serif';
                histCtx.textAlign = 'center';
                histCtx.fillText(labels[i], x + barWidth * 0.4, height - padding + 20);
            });
            
            // Extinct markers
            values.forEach((value, i) => {
                if (value < EXTINCTION_THRESHOLD) {
                    const x = padding + i * barWidth + barWidth * 0.5;
                    const y = height - padding + 35;
                    histCtx.fillStyle = '#ef4444';
                    histCtx.font = '10px sans-serif';
                    histCtx.textAlign = 'center';
                    histCtx.fillText('EXTINCT', x, y);
                }
            });
        }
        
        function draw() {
            ctx.fillStyle = '#fafafa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const showFlow = document.getElementById('showFlow').checked;
            const showTrajectory = document.getElementById('showTrajectory').checked;
            const showMetricEllipses = document.getElementById('showMetricEllipses').checked;
            const showGeodesic = document.getElementById('showGeodesic').checked;
            
            // Draw tetrahedron edges
            const edges = [
                [v1, v2], [v1, v3], [v1, v4],
                [v2, v3], [v3, v4], [v4, v2]
            ];
            
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 2;
            edges.forEach(([a, b]) => {
                const pa = project3D(a);
                const pb = project3D(b);
                ctx.beginPath();
                ctx.moveTo(pa.x, pa.y);
                ctx.lineTo(pb.x, pb.y);
                ctx.stroke();
            });
            
            // Draw faces
            const faces = [
                [v1, v2, v3],
                [v1, v3, v4],
                [v1, v4, v2],
                [v2, v3, v4]
            ];
            
            faces.forEach(face => {
                const projected = face.map(v => project3D(v));
                const avgZ = projected.reduce((sum, p) => sum + p.z, 0) / 3;
                
                ctx.fillStyle = avgZ > 0 ? 'rgba(230, 240, 250, 0.15)' : 'rgba(230, 240, 250, 0.05)';
                ctx.beginPath();
                ctx.moveTo(projected[0].x, projected[0].y);
                ctx.lineTo(projected[1].x, projected[1].y);
                ctx.lineTo(projected[2].x, projected[2].y);
                ctx.closePath();
                ctx.fill();
            });
            
            // Draw geodesic to center
            if (showGeodesic && currentPoint.x > EXTINCTION_THRESHOLD && 
                currentPoint.y > EXTINCTION_THRESHOLD && 
                currentPoint.z > EXTINCTION_THRESHOLD && 
                currentPoint.w > EXTINCTION_THRESHOLD) {
                const geodesic = computeGeodesicToCenter(currentPoint);
                
                ctx.strokeStyle = 'rgba(168, 85, 247, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                
                const first3D = baryTo3D(geodesic[0].x, geodesic[0].y, geodesic[0].z, geodesic[0].w);
                const firstProj = project3D(first3D);
                ctx.moveTo(firstProj.x, firstProj.y);
                
                for (let i = 1; i < geodesic.length; i++) {
                    const p3d = baryTo3D(geodesic[i].x, geodesic[i].y, geodesic[i].z, geodesic[i].w);
                    const proj = project3D(p3d);
                    ctx.lineTo(proj.x, proj.y);
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Draw metric ellipses at grid points
            if (showMetricEllipses) {
                const gridSize = 8;
                for (let i = 1; i < gridSize; i++) {
                    for (let j = 1; j < gridSize - i; j++) {
                        for (let k = 1; k < gridSize - i - j; k++) {
                            const l = gridSize - i - j - k;
                            if (l < 1) continue;
                            
                            const x = i / gridSize;
                            const y = j / gridSize;
                            const z = k / gridSize;
                            const w = l / gridSize;
                            
                            drawMetricEllipse({ x, y, z, w }, 0.025);
                        }
                    }
                }
            }

            // Draw metric ellipse at current point (dynamic - moves with point!)
            const showCurrentMetric = document.getElementById('showCurrentMetric').checked;
            if (showCurrentMetric && currentPoint.x > 0.02 && currentPoint.y > 0.02 && 
                currentPoint.z > 0.02 && currentPoint.w > 0.02) {
                drawCurrentMetricEllipse(currentPoint, 0.04);
            }
            
            // Label vertices
            const labels = [
                { v: v1, text: 'x', color: 'rgba(255, 50, 50, 1)' },
                { v: v2, text: 'y', color: 'rgba(50, 255, 50, 1)' },
                { v: v3, text: 'z', color: 'rgba(50, 100, 255, 1)' },
                { v: v4, text: 'w', color: 'rgba(255, 200, 50, 1)' }
            ];
            
            labels.forEach(({v, text, color}) => {
                const p = project3D(v);
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#1e293b';
                ctx.font = 'bold 16px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, p.x, p.y);
            });
            
            // Draw flow field
            if (showFlow) {
                const gridSize = 10;
                ctx.strokeStyle = 'rgba(100, 116, 139, 0.15)';
                ctx.lineWidth = 1;
                
                for (let i = 0; i <= gridSize; i++) {
                    for (let j = 0; j <= gridSize - i; j++) {
                        for (let k = 0; k <= gridSize - i - j; k++) {
                            const l = gridSize - i - j - k;
                            if (l < 0) continue;
                            
                            const x = i / gridSize;
                            const y = j / gridSize;
                            const z = k / gridSize;
                            const w = l / gridSize;
                            
                            const p3d = baryTo3D(x, y, z, w);
                            const pp = project3D(p3d);
                            
                            const vel = replicatorDynamics({x, y, z, w});
                            const pNext3d = baryTo3D(
                                x + vel.x * 0.03,
                                y + vel.y * 0.03,
                                z + vel.z * 0.03,
                                w + vel.w * 0.03
                            );
                            const ppNext = project3D(pNext3d);
                            
                            ctx.beginPath();
                            ctx.moveTo(pp.x, pp.y);
                            ctx.lineTo(ppNext.x, ppNext.y);
                            ctx.stroke();
                        }
                    }
                }
            }
            
            // Draw trajectories
            if (showTrajectory) {
                trajectories.forEach((traj, idx) => {
                    if (traj.length < 2) return;
                    
                    const alpha = idx === trajectories.length - 1 ? 0.6 : 0.2;
                    ctx.strokeStyle = `rgba(59, 130, 246, ${alpha})`;
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    ctx.beginPath();
                    const start = baryTo3D(traj[0].x, traj[0].y, traj[0].z, traj[0].w);
                    const pStart = project3D(start);
                    ctx.moveTo(pStart.x, pStart.y);
                    
                    for (let i = 1; i < traj.length; i++) {
                        const p3d = baryTo3D(traj[i].x, traj[i].y, traj[i].z, traj[i].w);
                        const pp = project3D(p3d);
                        ctx.lineTo(pp.x, pp.y);
                    }
                    ctx.stroke();
                });
            }
            
            // Draw current point
            const pos3D = baryTo3D(currentPoint.x, currentPoint.y, currentPoint.z, currentPoint.w);
            const proj = project3D(pos3D);
            
            ctx.fillStyle = 'rgba(239, 68, 68, 0.8)';
            ctx.strokeStyle = 'rgba(220, 38, 38, 1)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(proj.x, proj.y, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            drawHistogram();
        }
        
        function animate() {
            const dt = 0.01 * speed;
            const vel = replicatorDynamics(currentPoint);
            
            currentPoint.x += vel.x * dt;
            currentPoint.y += vel.y * dt;
            currentPoint.z += vel.z * dt;
            currentPoint.w += vel.w * dt;
            
            if (currentPoint.x < EXTINCTION_THRESHOLD) currentPoint.x = 0;
            if (currentPoint.y < EXTINCTION_THRESHOLD) currentPoint.y = 0;
            if (currentPoint.z < EXTINCTION_THRESHOLD) currentPoint.z = 0;
            if (currentPoint.w < EXTINCTION_THRESHOLD) currentPoint.w = 0;
            
            const sum = currentPoint.x + currentPoint.y + currentPoint.z + currentPoint.w;
            if (sum > 0) {
                currentPoint.x /= sum;
                currentPoint.y /= sum;
                currentPoint.z /= sum;
                currentPoint.w /= sum;
            }
            
            updateDisplay();
            
            if (trajectories.length > 0) {
                const lastTraj = trajectories[trajectories.length - 1];
                lastTraj.push({ ...currentPoint });
                if (tailLength > 0 && lastTraj.length > tailLength) {
                    lastTraj.shift();
                }
            }
            
            draw();
            
            if (isPlaying) {
                animationId = requestAnimationFrame(animate);
            }
        }
        
        function togglePlay() {
            isPlaying = !isPlaying;
            const playBtn = document.getElementById('playBtn');
            const playIcon = document.getElementById('playIcon');
            const playText = document.getElementById('playText');
            
            if (isPlaying) {
                playBtn.classList.add('playing');
                playIcon.textContent = '⏸';
                playText.textContent = 'Pause';
                if (trajectories.length === 0) {
                    trajectories.push([]);
                }
                requestAnimationFrame(animate);
            } else {
                playBtn.classList.remove('playing');
                playIcon.textContent = '▶';
                playText.textContent = 'Play';
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
            }
        }
        
        function reset() {
            isPlaying = false;
            const playBtn = document.getElementById('playBtn');
            playBtn.classList.remove('playing');
            document.getElementById('playIcon').textContent = '▶';
            document.getElementById('playText').textContent = 'Play';
            
            if (animationId) cancelAnimationFrame(animationId);
            
            currentPoint = { x: 0.25, y: 0.25, z: 0.25, w: 0.25 };
            trajectories = [];
            updateDisplay();
            draw();
        }
        
        function changeGameType() {
            gameType = document.getElementById('gameType').value;
            reset();
        }
        
        function updateSpeed() {
            speed = parseFloat(document.getElementById('speed').value);
            document.getElementById('speedValue').textContent = speed.toFixed(1) + '×';
        }
        
        function updateTailLength() {
            tailLength = parseInt(document.getElementById('tailLength').value);
            
            if (tailLength > 0) {
                trajectories.forEach(traj => {
                    if (traj.length > tailLength) {
                        traj.splice(0, traj.length - tailLength);
                    }
                });
            }
            draw();
        }
        
        function updateDisplay() {
            const coordSystem = document.querySelector('input[name="coordSystem"]:checked').value;
            const format = (x) => x.toFixed(3);
            
            if (coordSystem === 'barycentric') {
                // Update mode label
                document.getElementById('coordModeLabel').textContent = '(Barycentric)';
                document.getElementById('coordModeLabel').style.color = '#3b82f6';
                
                // Update row labels
                document.getElementById('label1').textContent = 'Strategy 1 (x):';
                document.getElementById('label2').textContent = 'Strategy 2 (y):';
                document.getElementById('label3').textContent = 'Strategy 3 (z):';
                document.getElementById('label4').textContent = 'Strategy 4 (w):';
                
                // Display barycentric coordinates (probabilities)
                document.getElementById('x1').textContent = format(currentPoint.x);
                document.getElementById('x2').textContent = format(currentPoint.y);
                document.getElementById('x3').textContent = format(currentPoint.z);
                document.getElementById('x4').textContent = format(currentPoint.w);
            } else {
                // Update mode label
                document.getElementById('coordModeLabel').textContent = '(Log-Ratio)';
                document.getElementById('coordModeLabel').style.color = '#8b5cf6';
                
                // Update row labels to show log-ratio
                document.getElementById('label1').textContent = 'log(x/g) - centered:';
                document.getElementById('label2').textContent = 'log(y/g) - centered:';
                document.getElementById('label3').textContent = 'log(z/g) - centered:';
                document.getElementById('label4').textContent = 'log(w/g) - centered:';
                
                // Log-ratio coordinates
                const clr = centeredLogRatio(currentPoint);
                document.getElementById('x1').textContent = format(clr[0]);
                document.getElementById('x2').textContent = format(clr[1]);
                document.getElementById('x3').textContent = format(clr[2]);
                document.getElementById('x4').textContent = format(clr[3]);
            }
            
            // Mark extinct strategies
            const rows = ['row1', 'row2', 'row3', 'row4'];
            const vals = [currentPoint.x, currentPoint.y, currentPoint.z, currentPoint.w];
            rows.forEach((row, i) => {
                if (vals[i] < EXTINCTION_THRESHOLD) {
                    document.getElementById(row).classList.add('extinct');
                } else {
                    document.getElementById(row).classList.remove('extinct');
                }
            });
            
            const A = matrices[gameType];
            const fitness = [
                A[0][0] * currentPoint.x + A[0][1] * currentPoint.y + A[0][2] * currentPoint.z + A[0][3] * currentPoint.w,
                A[1][0] * currentPoint.x + A[1][1] * currentPoint.y + A[1][2] * currentPoint.z + A[1][3] * currentPoint.w,
                A[2][0] * currentPoint.x + A[2][1] * currentPoint.y + A[2][2] * currentPoint.z + A[2][3] * currentPoint.w,
                A[3][0] * currentPoint.x + A[3][1] * currentPoint.y + A[3][2] * currentPoint.z + A[3][3] * currentPoint.w
            ];
            const avgFitness = currentPoint.x * fitness[0] + currentPoint.y * fitness[1] + 
                             currentPoint.z * fitness[2] + currentPoint.w * fitness[3];
            document.getElementById('fitness').textContent = avgFitness.toFixed(4);
            
            let activeDim = 0;
            if (currentPoint.x >= EXTINCTION_THRESHOLD) activeDim++;
            if (currentPoint.y >= EXTINCTION_THRESHOLD) activeDim++;
            if (currentPoint.z >= EXTINCTION_THRESHOLD) activeDim++;
            if (currentPoint.w >= EXTINCTION_THRESHOLD) activeDim++;
            document.getElementById('dimension').textContent = activeDim - 1;
            
            // Information-geometric quantities
            const entropy = shannonEntropy(currentPoint);
            const uniform = { x: 0.25, y: 0.25, z: 0.25, w: 0.25 };
            const kl = klDivergence(currentPoint, uniform);
            const frDist = fisherRaoDistance(currentPoint, uniform);
            
            document.getElementById('entropy').textContent = entropy.toFixed(4);
            document.getElementById('klDiv').textContent = kl.toFixed(4);
            document.getElementById('fisherDist').textContent = frDist.toFixed(4);
            
            // Display Fisher metric
            const g = fisherMetricMatrix(currentPoint);
            let metricHTML = '<strong>Fisher Metric g_ij:</strong><br>';
            metricHTML += '<table style="font-size: 10px; border-collapse: collapse;">';
            for (let i = 0; i < 4; i++) {
                metricHTML += '<tr>';
                for (let j = 0; j < 4; j++) {
                    const val = g[i][j].toFixed(2);
                    metricHTML += `<td style="padding: 2px 6px; text-align: right;">${val}</td>`;
                }
                metricHTML += '</tr>';
            }
            metricHTML += '</table>';
            document.getElementById('fisherMetricDisplay').innerHTML = metricHTML;
        }
        
        // Mouse controls
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const startX = e.clientX;
            const startY = e.clientY;
            const startTime = Date.now();
            
            isDragging = true;
            lastMouseX = startX;
            lastMouseY = startY;
            
            const mouseUpHandler = (upEvent) => {
                const endX = upEvent.clientX;
                const endY = upEvent.clientY;
                const endTime = Date.now();
                const dist = Math.sqrt((endX-startX)**2 + (endY-startY)**2);
                const duration = endTime - startTime;
                
                isDragging = false;
                
                if (dist < 5 && duration < 200) {
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const mouseX = (upEvent.clientX - rect.left) * scaleX;
                    const mouseY = (upEvent.clientY - rect.top) * scaleY;
                    setPointFromClick(mouseX, mouseY);
                }
                
                canvas.removeEventListener('mouseup', mouseUpHandler);
            };
            
            canvas.addEventListener('mouseup', mouseUpHandler);
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                
                rotationY += dx * 0.01;
                rotationX += dy * 0.01;
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                
                draw();
            }
        });
        
        document.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            zoom *= (1 - e.deltaY * 0.001);
            zoom = Math.max(0.3, Math.min(3, zoom));
            draw();
        });
        
        function setPointFromClick(mouseX, mouseY) {
            let bestDist = Infinity;
            let bestPoint = null;
            
            const gridSize = 15;
            for (let i = 0; i <= gridSize; i++) {
                for (let j = 0; j <= gridSize-i; j++) {
                    for (let k = 0; k <= gridSize-i-j; k++) {
                        const l = gridSize-i-j-k;
                        if (l < 0) continue;
                        
                        const x = i/gridSize, y = j/gridSize, z = k/gridSize, w = l/gridSize;
                        
                        const pos3D = baryTo3D(x, y, z, w);
                        const proj = project3D(pos3D);
                        
                        const dist = Math.sqrt((proj.x - mouseX)**2 + (proj.y - mouseY)**2);
                        
                        if (dist < bestDist) {
                            bestDist = dist;
                            bestPoint = { x, y, z, w };
                        }
                    }
                }
            }
            
            if (bestPoint && bestDist < 150) {
                currentPoint = { ...bestPoint };
                trajectories.push([]);
                updateDisplay();
                draw();
            }
        }
        
        function setInteriorPoint() {
            const base = 0.25;
            const spread = 0.15;
            currentPoint = {
                x: base + (Math.random() - 0.5) * spread,
                y: base + (Math.random() - 0.5) * spread,
                z: base + (Math.random() - 0.5) * spread,
                w: base + (Math.random() - 0.5) * spread
            };
            
            const sum = currentPoint.x + currentPoint.y + currentPoint.z + currentPoint.w;
            currentPoint.x /= sum;
            currentPoint.y /= sum;
            currentPoint.z /= sum;
            currentPoint.w /= sum;
            
            trajectories.push([]);
            updateDisplay();
            draw();
        }
        
        updateDisplay();
        draw();
    </script>
</body>
</html>
