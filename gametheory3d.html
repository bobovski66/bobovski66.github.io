<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4-Strategy Replicator Dynamics (3-Simplex)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(to bottom right, #f8fafc, #e2e8f0);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            padding: 24px;
        }
        
        .header {
            margin-bottom: 20px;
        }
        
        .header h1 {
            font-size: 24px;
            color: #1e293b;
            margin-bottom: 4px;
        }
        
        .header p {
            font-size: 14px;
            color: #64748b;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 24px;
        }
        
        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
        
        canvas {
            width: 100%;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: #fafafa;
            cursor: move;
        }

        #histogramCanvas {
            cursor: default;
            height: 250px !important;
        }
        
        .controls {
            background: #f8fafc;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
        }
        
        .controls h3 {
            font-size: 16px;
            color: #1e293b;
            margin-bottom: 12px;
        }
        
        .button-group {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }
        
        button {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
        }
        
        .play-btn {
            flex: 1;
            background: #22c55e;
            color: white;
        }
        
        .play-btn:hover {
            background: #16a34a;
        }
        
        .play-btn.playing {
            background: #ef4444;
        }
        
        .play-btn.playing:hover {
            background: #dc2626;
        }
        
        .reset-btn {
            padding: 10px 16px;
            background: #e2e8f0;
            color: #475569;
        }
        
        .reset-btn:hover {
            background: #cbd5e1;
        }
        
        label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: #1e293b;
            margin-bottom: 8px;
        }
        
        select, input[type="range"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            font-size: 14px;
        }
        
        .slider-group {
            margin-bottom: 12px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 13px;
        }
        
        input[type="range"] {
            padding: 0;
            height: 6px;
        }
        
        .state-box {
            background: #f8fafc;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
        }
        
        .state-box h3 {
            font-size: 16px;
            color: #1e293b;
            margin-bottom: 12px;
        }
        
        .state-row {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            margin-bottom: 8px;
        }
        
        .state-row span:first-child {
            color: #64748b;
        }
        
        .state-row span:last-child {
            font-family: 'Courier New', monospace;
        }
        
        .extinct {
            opacity: 0.4;
            text-decoration: line-through;
        }
        
        .info-box {
            background: #fef3c7;
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            color: #64748b;
            margin-bottom: 12px;
        }
        
        .info-box p:first-child {
            font-weight: 600;
            margin-bottom: 4px;
            color: #1e293b;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
        }

        .checkbox-group label {
            margin: 0;
            font-weight: normal;
        }

        .histogram-box {
            background: #f8fafc;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .histogram-box h3 {
            font-size: 16px;
            color: #1e293b;
            margin-bottom: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>4-Strategy Replicator Dynamics (3-Simplex)</h1>
            <p>Hierarchical stratified flow with face reduction</p>
        </div>

        <div class="main-grid">
            <div>
                <canvas id="canvas" width="700" height="700"></canvas>
                <p style="font-size: 12px; color: #64748b; margin-top: 8px;">
                    Drag to rotate • Scroll to zoom
                </p>
            </div>

            <div>
                <div class="controls">
                    <h3>Controls</h3>
                    <div class="button-group">
                        <button class="play-btn" id="playBtn" onclick="togglePlay()">
                            <span id="playIcon">▶</span>
                            <span id="playText">Play</span>
                        </button>
                        <button class="reset-btn" onclick="reset()">Reset</button>
                    </div>

                    <button class="reset-btn" onclick="setInteriorPoint()" style="width: 100%; margin-bottom: 16px;">
                        Random Interior Point
                    </button>

                    <label for="gameType">Game Type</label>
                    <select id="gameType" onchange="changeGameType()">
                        <option value="cyclic">Cyclic (Rock-Paper-Scissors-Lizard)</option>
                        <option value="coordination">Coordination Game</option>
                        <option value="prisoner">Prisoner's Dilemma</option>
                        <option value="mixed">Mixed Dynamics</option>
                    </select>

                    <div class="slider-group" style="margin-top: 16px;">
                        <div class="slider-label">
                            <span>Animation Speed</span>
                            <span id="speedValue">1.0×</span>
                        </div>
                        <input type="range" id="speed" min="0.1" max="5" step="0.1" value="1" oninput="updateSpeed()">
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="showFlow" checked onchange="draw()">
                        <label for="showFlow">Show flow field</label>
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="showTrajectory" checked onchange="draw()">
                        <label for="showTrajectory">Show trajectory</label>
                    </div>
                </div>

                <div class="histogram-box">
                    <h3>Strategy Mixture</h3>
                    <canvas id="histogramCanvas" width="350" height="250"></canvas>
                </div>

                <div class="state-box">
                    <h3>Current State</h3>
                    <div class="state-row" id="row1">
                        <span>Strategy 1 (x):</span>
                        <span id="x1">0.250</span>
                    </div>
                    <div class="state-row" id="row2">
                        <span>Strategy 2 (y):</span>
                        <span id="x2">0.250</span>
                    </div>
                    <div class="state-row" id="row3">
                        <span>Strategy 3 (z):</span>
                        <span id="x3">0.250</span>
                    </div>
                    <div class="state-row" id="row4">
                        <span>Strategy 4 (w):</span>
                        <span id="x4">0.250</span>
                    </div>
                    <hr style="margin: 12px 0; border: none; border-top: 1px solid #e2e8f0;">
                    <div class="state-row">
                        <span>Avg Fitness:</span>
                        <span id="fitness">0.0000</span>
                    </div>
                    <div class="state-row">
                        <span>Active Dimension:</span>
                        <span id="dimension">3</span>
                    </div>
                </div>

                <div class="info-box">
                    <p>How to use:</p>
                    Click anywhere on the tetrahedron to place the point. Press Play to watch the dynamics evolve. The point will flow according to replicator dynamics, potentially reducing to lower-dimensional faces as strategies go extinct.
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const histCanvas = document.getElementById('histogramCanvas');
        const histCtx = histCanvas.getContext('2d');

        // State
        let currentPoint = { x: 0.25, y: 0.25, z: 0.25, w: 0.25 };
        let trajectories = [];
        let isPlaying = false;
        let animationId = null;
        let speed = 1.0;
        let gameType = 'cyclic';
        
        // View control
        let rotationX = -0.3;
        let rotationY = 0.7;
        let zoom = 1.2;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        const EXTINCTION_THRESHOLD = 0.001;
        
        // Game matrices
        const matrices = {
            cyclic: [
                [0, -1, 1, 0.5],
                [1, 0, -1, 0.5],
                [-1, 1, 0, -0.5],
                [-0.5, -0.5, 0.5, 0]
            ],
            coordination: [
                [2, 0, 0, 1],
                [0, 2, 1, 0],
                [0, 1, 2, 0],
                [1, 0, 0, 2]
            ],
            prisoner: [
                [3, 0, 2, 1],
                [5, 1, 3, 2],
                [2, 3, 3, 1],
                [1, 2, 1, 2]
            ],
            mixed: [
                [1, 2, -1, 0],
                [-1, 1, 2, 1],
                [2, -1, 1, -1],
                [0, 1, -1, 1]
            ]
        };
        
        // Tetrahedron vertices in 3D
        const v1 = { x: 0, y: 1, z: 0 };
        const v2 = { x: Math.cos(0), y: 0, z: Math.sin(0) };
        const v3 = { x: Math.cos(2*Math.PI/3), y: 0, z: Math.sin(2*Math.PI/3) };
        const v4 = { x: Math.cos(4*Math.PI/3), y: 0, z: Math.sin(4*Math.PI/3) };
        
        function baryTo3D(x, y, z, w) {
            return {
                x: x * v1.x + y * v2.x + z * v3.x + w * v4.x,
                y: x * v1.y + y * v2.y + z * v3.y + w * v4.y,
                z: x * v1.z + y * v2.z + z * v3.z + w * v4.z
            };
        }
        
        function rotate3D(p) {
            let x = p.x, y = p.y, z = p.z;
            
            let y1 = y * Math.cos(rotationX) - z * Math.sin(rotationX);
            let z1 = y * Math.sin(rotationX) + z * Math.cos(rotationX);
            
            let x2 = x * Math.cos(rotationY) + z1 * Math.sin(rotationY);
            let z2 = -x * Math.sin(rotationY) + z1 * Math.cos(rotationY);
            
            return { x: x2, y: y1, z: z2 };
        }
        
        function project3D(p) {
            const scale = 250 * zoom;
            const rotated = rotate3D(p);
            return {
                x: canvas.width/2 + rotated.x * scale,
                y: canvas.height/2 - rotated.y * scale,
                z: rotated.z
            };
        }
        
        function replicatorDynamics(p) {
            const A = matrices[gameType];
            
            const fitness = [
                A[0][0] * p.x + A[0][1] * p.y + A[0][2] * p.z + A[0][3] * p.w,
                A[1][0] * p.x + A[1][1] * p.y + A[1][2] * p.z + A[1][3] * p.w,
                A[2][0] * p.x + A[2][1] * p.y + A[2][2] * p.z + A[2][3] * p.w,
                A[3][0] * p.x + A[3][1] * p.y + A[3][2] * p.z + A[3][3] * p.w
            ];
            
            const avgFitness = p.x * fitness[0] + p.y * fitness[1] + 
                             p.z * fitness[2] + p.w * fitness[3];
            
            return {
                x: p.x * (fitness[0] - avgFitness),
                y: p.y * (fitness[1] - avgFitness),
                z: p.z * (fitness[2] - avgFitness),
                w: p.w * (fitness[3] - avgFitness)
            };
        }
        
        function drawHistogram() {
            const width = histCanvas.width;
            const height = histCanvas.height;
            const padding = 40;
            const barWidth = (width - 2 * padding) / 4;
            const maxHeight = height - 2 * padding;
            
            // Clear
            histCtx.clearRect(0, 0, width, height);
            
            // Define colors matching the tetrahedron vertices
            const colors = [
                'rgba(255, 50, 50, 0.8)',   // Strategy 1 (x) - red
                'rgba(50, 255, 50, 0.8)',   // Strategy 2 (y) - green
                'rgba(50, 100, 255, 0.8)',  // Strategy 3 (z) - blue
                'rgba(255, 200, 50, 0.8)'   // Strategy 4 (w) - yellow
            ];
            
            const values = [currentPoint.x, currentPoint.y, currentPoint.z, currentPoint.w];
            const labels = ['x', 'y', 'z', 'w'];
            
            // Draw axes
            histCtx.strokeStyle = '#cbd5e1';
            histCtx.lineWidth = 2;
            histCtx.beginPath();
            histCtx.moveTo(padding, padding);
            histCtx.lineTo(padding, height - padding);
            histCtx.lineTo(width - padding, height - padding);
            histCtx.stroke();
            
            // Draw grid lines
            histCtx.strokeStyle = '#e2e8f0';
            histCtx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = padding + (maxHeight * i / 5);
                histCtx.beginPath();
                histCtx.moveTo(padding, y);
                histCtx.lineTo(width - padding, y);
                histCtx.stroke();
                
                // Y-axis labels
                histCtx.fillStyle = '#64748b';
                histCtx.font = '11px sans-serif';
                histCtx.textAlign = 'right';
                histCtx.fillText((1 - i/5).toFixed(1), padding - 8, y + 4);
            }
            
            // Draw bars
            values.forEach((value, i) => {
                const x = padding + i * barWidth + barWidth * 0.1;
                const barH = value * maxHeight;
                const barY = height - padding - barH;
                
                // Draw bar
                histCtx.fillStyle = colors[i];
                histCtx.fillRect(x, barY, barWidth * 0.8, barH);
                
                // Draw outline
                histCtx.strokeStyle = colors[i].replace('0.8', '1');
                histCtx.lineWidth = 2;
                histCtx.strokeRect(x, barY, barWidth * 0.8, barH);
                
                // Draw value on top
                if (value > 0.02) {
                    histCtx.fillStyle = '#1e293b';
                    histCtx.font = 'bold 13px sans-serif';
                    histCtx.textAlign = 'center';
                    histCtx.fillText(value.toFixed(3), x + barWidth * 0.4, barY - 8);
                }
                
                // Draw label below
                histCtx.fillStyle = '#1e293b';
                histCtx.font = 'bold 14px sans-serif';
                histCtx.textAlign = 'center';
                histCtx.fillText(labels[i], x + barWidth * 0.4, height - padding + 20);
            });
            
            // Extinct markers
            values.forEach((value, i) => {
                if (value < EXTINCTION_THRESHOLD) {
                    const x = padding + i * barWidth + barWidth * 0.5;
                    const y = height - padding + 35;
                    histCtx.fillStyle = '#ef4444';
                    histCtx.font = '11px sans-serif';
                    histCtx.textAlign = 'center';
                    histCtx.fillText('EXTINCT', x, y);
                }
            });
        }
        
        function draw() {
            ctx.fillStyle = '#fafafa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const showFlow = document.getElementById('showFlow').checked;
            const showTrajectory = document.getElementById('showTrajectory').checked;
            
            // Draw tetrahedron edges
            const edges = [
                [v1, v2], [v1, v3], [v1, v4],
                [v2, v3], [v3, v4], [v4, v2]
            ];
            
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 2;
            edges.forEach(([a, b]) => {
                const pa = project3D(a);
                const pb = project3D(b);
                ctx.beginPath();
                ctx.moveTo(pa.x, pa.y);
                ctx.lineTo(pb.x, pb.y);
                ctx.stroke();
            });
            
            // Draw faces with transparency
            const faces = [
                [v1, v2, v3],
                [v1, v3, v4],
                [v1, v4, v2],
                [v2, v3, v4]
            ];
            
            faces.forEach(face => {
                const projected = face.map(v => project3D(v));
                const avgZ = projected.reduce((sum, p) => sum + p.z, 0) / 3;
                
                ctx.fillStyle = avgZ > 0 ? 'rgba(230, 240, 250, 0.15)' : 'rgba(230, 240, 250, 0.05)';
                ctx.beginPath();
                ctx.moveTo(projected[0].x, projected[0].y);
                ctx.lineTo(projected[1].x, projected[1].y);
                ctx.lineTo(projected[2].x, projected[2].y);
                ctx.closePath();
                ctx.fill();
            });
            
            // Label vertices
            const labels = [
                { v: v1, text: 'x', color: 'rgba(255, 50, 50, 1)' },
                { v: v2, text: 'y', color: 'rgba(50, 255, 50, 1)' },
                { v: v3, text: 'z', color: 'rgba(50, 100, 255, 1)' },
                { v: v4, text: 'w', color: 'rgba(255, 200, 50, 1)' }
            ];
            
            labels.forEach(({v, text, color}) => {
                const p = project3D(v);
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#1e293b';
                ctx.font = 'bold 16px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, p.x, p.y);
            });
            
            // Draw flow field
            if (showFlow) {
                const gridSize = 12;
                ctx.strokeStyle = 'rgba(100, 116, 139, 0.15)';
                ctx.lineWidth = 1;
                
                for (let i = 0; i <= gridSize; i++) {
                    for (let j = 0; j <= gridSize - i; j++) {
                        for (let k = 0; k <= gridSize - i - j; k++) {
                            const l = gridSize - i - j - k;
                            if (l < 0) continue;
                            
                            const x = i / gridSize;
                            const y = j / gridSize;
                            const z = k / gridSize;
                            const w = l / gridSize;
                            
                            const p3d = baryTo3D(x, y, z, w);
                            const pp = project3D(p3d);
                            
                            const vel = replicatorDynamics({x, y, z, w});
                            const pNext3d = baryTo3D(
                                x + vel.x * 0.03,
                                y + vel.y * 0.03,
                                z + vel.z * 0.03,
                                w + vel.w * 0.03
                            );
                            const ppNext = project3D(pNext3d);
                            
                            ctx.beginPath();
                            ctx.moveTo(pp.x, pp.y);
                            ctx.lineTo(ppNext.x, ppNext.y);
                            ctx.stroke();
                        }
                    }
                }
            }
            
            // Draw trajectories
            if (showTrajectory) {
                trajectories.forEach((traj, idx) => {
                    if (traj.length < 2) return;
                    
                    const alpha = idx === trajectories.length - 1 ? 0.6 : 0.2;
                    ctx.strokeStyle = `rgba(59, 130, 246, ${alpha})`;
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    ctx.beginPath();
                    const start = baryTo3D(traj[0].x, traj[0].y, traj[0].z, traj[0].w);
                    const pStart = project3D(start);
                    ctx.moveTo(pStart.x, pStart.y);
                    
                    for (let i = 1; i < traj.length; i++) {
                        const p3d = baryTo3D(traj[i].x, traj[i].y, traj[i].z, traj[i].w);
                        const pp = project3D(p3d);
                        ctx.lineTo(pp.x, pp.y);
                    }
                    ctx.stroke();
                });
            }
            
            // Draw current point
            const pos3D = baryTo3D(currentPoint.x, currentPoint.y, currentPoint.z, currentPoint.w);
            const proj = project3D(pos3D);
            
            ctx.fillStyle = 'rgba(239, 68, 68, 0.8)';
            ctx.strokeStyle = 'rgba(220, 38, 38, 1)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(proj.x, proj.y, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Draw histogram
            drawHistogram();
        }
        
        function animate() {
            const dt = 0.01 * speed;
            const vel = replicatorDynamics(currentPoint);
            
            currentPoint.x += vel.x * dt;
            currentPoint.y += vel.y * dt;
            currentPoint.z += vel.z * dt;
            currentPoint.w += vel.w * dt;
            
            // Apply extinction threshold
            if (currentPoint.x < EXTINCTION_THRESHOLD) currentPoint.x = 0;
            if (currentPoint.y < EXTINCTION_THRESHOLD) currentPoint.y = 0;
            if (currentPoint.z < EXTINCTION_THRESHOLD) currentPoint.z = 0;
            if (currentPoint.w < EXTINCTION_THRESHOLD) currentPoint.w = 0;
            
            // Renormalize
            const sum = currentPoint.x + currentPoint.y + currentPoint.z + currentPoint.w;
            if (sum > 0) {
                currentPoint.x /= sum;
                currentPoint.y /= sum;
                currentPoint.z /= sum;
                currentPoint.w /= sum;
            }
            
            updateDisplay();
            
            // Track trajectory
            if (trajectories.length > 0) {
                const lastTraj = trajectories[trajectories.length - 1];
                lastTraj.push({ ...currentPoint });
                if (lastTraj.length > 300) lastTraj.shift();
            }
            
            draw();
            
            if (isPlaying) {
                animationId = requestAnimationFrame(animate);
            }
        }
        
        function togglePlay() {
            isPlaying = !isPlaying;
            const playBtn = document.getElementById('playBtn');
            const playIcon = document.getElementById('playIcon');
            const playText = document.getElementById('playText');
            
            if (isPlaying) {
                playBtn.classList.add('playing');
                playIcon.textContent = '⏸';
                playText.textContent = 'Pause';
                if (trajectories.length === 0) {
                    trajectories.push([]);
                }
                requestAnimationFrame(animate);
            } else {
                playBtn.classList.remove('playing');
                playIcon.textContent = '▶';
                playText.textContent = 'Play';
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
            }
        }
        
        function reset() {
            isPlaying = false;
            const playBtn = document.getElementById('playBtn');
            playBtn.classList.remove('playing');
            document.getElementById('playIcon').textContent = '▶';
            document.getElementById('playText').textContent = 'Play';
            
            if (animationId) cancelAnimationFrame(animationId);
            
            currentPoint = { x: 0.25, y: 0.25, z: 0.25, w: 0.25 };
            trajectories = [];
            updateDisplay();
            draw();
        }
        
        function changeGameType() {
            gameType = document.getElementById('gameType').value;
            reset();
        }
        
        function updateSpeed() {
            speed = parseFloat(document.getElementById('speed').value);
            document.getElementById('speedValue').textContent = speed.toFixed(1) + '×';
        }
        
        function updateDisplay() {
            const format = (x) => x.toFixed(3);
            
            document.getElementById('x1').textContent = format(currentPoint.x);
            document.getElementById('x2').textContent = format(currentPoint.y);
            document.getElementById('x3').textContent = format(currentPoint.z);
            document.getElementById('x4').textContent = format(currentPoint.w);
            
            // Mark extinct strategies
            const rows = ['row1', 'row2', 'row3', 'row4'];
            const vals = [currentPoint.x, currentPoint.y, currentPoint.z, currentPoint.w];
            rows.forEach((row, i) => {
                if (vals[i] < EXTINCTION_THRESHOLD) {
                    document.getElementById(row).classList.add('extinct');
                } else {
                    document.getElementById(row).classList.remove('extinct');
                }
            });
            
            const A = matrices[gameType];
            const fitness = [
                A[0][0] * currentPoint.x + A[0][1] * currentPoint.y + A[0][2] * currentPoint.z + A[0][3] * currentPoint.w,
                A[1][0] * currentPoint.x + A[1][1] * currentPoint.y + A[1][2] * currentPoint.z + A[1][3] * currentPoint.w,
                A[2][0] * currentPoint.x + A[2][1] * currentPoint.y + A[2][2] * currentPoint.z + A[2][3] * currentPoint.w,
                A[3][0] * currentPoint.x + A[3][1] * currentPoint.y + A[3][2] * currentPoint.z + A[3][3] * currentPoint.w
            ];
            const avgFitness = currentPoint.x * fitness[0] + currentPoint.y * fitness[1] + 
                             currentPoint.z * fitness[2] + currentPoint.w * fitness[3];
            document.getElementById('fitness').textContent = avgFitness.toFixed(4);
            
            // Calculate active dimension
            let activeDim = 0;
            if (currentPoint.x >= EXTINCTION_THRESHOLD) activeDim++;
            if (currentPoint.y >= EXTINCTION_THRESHOLD) activeDim++;
            if (currentPoint.z >= EXTINCTION_THRESHOLD) activeDim++;
            if (currentPoint.w >= EXTINCTION_THRESHOLD) activeDim++;
            document.getElementById('dimension').textContent = activeDim - 1;
        }
        
        // Mouse controls
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const startX = e.clientX;
            const startY = e.clientY;
            const startTime = Date.now();
            
            isDragging = true;
            lastMouseX = startX;
            lastMouseY = startY;
            
            const mouseUpHandler = (upEvent) => {
                const endX = upEvent.clientX;
                const endY = upEvent.clientY;
                const endTime = Date.now();
                const dist = Math.sqrt((endX-startX)**2 + (endY-startY)**2);
                const duration = endTime - startTime;
                
                isDragging = false;
                
                // Only treat as click if movement is small and duration is short
                if (dist < 5 && duration < 200) {
                    // Convert from screen coordinates to canvas coordinates
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const mouseX = (upEvent.clientX - rect.left) * scaleX;
                    const mouseY = (upEvent.clientY - rect.top) * scaleY;
                    setPointFromClick(mouseX, mouseY);
                }
                
                canvas.removeEventListener('mouseup', mouseUpHandler);
            };
            
            canvas.addEventListener('mouseup', mouseUpHandler);
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                
                rotationY += dx * 0.01;
                rotationX += dy * 0.01;
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                
                draw();
            }
        });
        
        document.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            zoom *= (1 - e.deltaY * 0.001);
            zoom = Math.max(0.3, Math.min(3, zoom));
            draw();
        });
        
        function setPointFromClick(mouseX, mouseY) {
            // Find closest point on tetrahedron to the click
            // Use a fine grid to sample all regions
            
            let bestDist = Infinity;
            let bestPoint = null;
            
            const gridSize = 15; // Finer grid
            for (let i = 0; i <= gridSize; i++) {
                for (let j = 0; j <= gridSize-i; j++) {
                    for (let k = 0; k <= gridSize-i-j; k++) {
                        const l = gridSize-i-j-k;
                        if (l < 0) continue;
                        
                        const x = i/gridSize, y = j/gridSize, z = k/gridSize, w = l/gridSize;
                        
                        const pos3D = baryTo3D(x, y, z, w);
                        const proj = project3D(pos3D);
                        
                        const dist = Math.sqrt((proj.x - mouseX)**2 + (proj.y - mouseY)**2);
                        
                        if (dist < bestDist) {
                            bestDist = dist;
                            bestPoint = { x, y, z, w };
                        }
                    }
                }
            }
            
            if (bestPoint && bestDist < 150) {
                console.log('Click found point: x=' + bestPoint.x.toFixed(3) + 
                           ' y=' + bestPoint.y.toFixed(3) + 
                           ' z=' + bestPoint.z.toFixed(3) + 
                           ' w=' + bestPoint.w.toFixed(3) + 
                           ' distance=' + bestDist.toFixed(1));
                
                // Use exact point from grid
                currentPoint = { ...bestPoint };
                
                // Start fresh trajectory but keep playing if already playing
                trajectories.push([]);
                
                updateDisplay();
                draw();
            } else {
                console.log('Click too far from tetrahedron:', bestDist);
            }
        }
        
        function setInteriorPoint() {
            // Set point deep in the interior, far from all faces
            const base = 0.25;
            const spread = 0.15;
            currentPoint = {
                x: base + (Math.random() - 0.5) * spread,
                y: base + (Math.random() - 0.5) * spread,
                z: base + (Math.random() - 0.5) * spread,
                w: base + (Math.random() - 0.5) * spread
            };
            
            // Normalize
            const sum = currentPoint.x + currentPoint.y + currentPoint.z + currentPoint.w;
            currentPoint.x /= sum;
            currentPoint.y /= sum;
            currentPoint.z /= sum;
            currentPoint.w /= sum;
            
            console.log('Interior point: x=' + currentPoint.x.toFixed(3) + 
                       ' y=' + currentPoint.y.toFixed(3) + 
                       ' z=' + currentPoint.z.toFixed(3) + 
                       ' w=' + currentPoint.w.toFixed(3));
            
            trajectories.push([]);
            updateDisplay();
            draw();
        }
        
        updateDisplay();
        draw();
    </script>
</body>
</html>
