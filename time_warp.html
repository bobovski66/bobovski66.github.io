<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Reeb Overload → EM Time Dilation (Vanilla HTML/JS, Retrograde + Proportional)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #f8fafc; --fg: #0f172a; --muted: #64748b;
      --panel: #ffffff; --panel2: #e2e8f0;
      --green: #10b981; --blue: #0ea5e9; --rose: #f43f5e;
    }
    * { box-sizing: border-box; }
    body { margin: 0; background: var(--bg); color: var(--fg); font: 16px/1.45 system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
    .wrap { max-width: 1200px; margin: 0 auto; padding: 24px; display: grid; grid-template-columns: 1fr; gap: 24px; }
    @media (min-width: 980px) { .wrap { grid-template-columns: 1fr 1fr; } }
    h1 { font-size: 22px; margin: 0; }
    p.meta { color: #334155; font-size: 13px; margin: 8px 0 0 0; }
    .card { background: var(--panel); border-radius: 16px; box-shadow: 0 2px 18px rgba(0,0,0,0.06); padding: 16px; }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-top: 8px; }
    .control { opacity: 1; }
    .control.disabled { opacity: 0.5; }
    label { font-size: 13px; display: block; margin: 8px 0 4px; }
    input[type=range] { width: 100%; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .small { font-size: 12px; color: var(--muted); }
    .btn { border: 1px solid #cbd5e1; background: #fff; color: var(--fg); border-radius: 10px; padding: 8px 12px; cursor: pointer; }
    .btn.primary { background: #111827; color: #fff; border-color: #111827; }
    .btn.green { background: #059669; color: #fff; border-color: #059669; }
    .chip { font-size: 12px; border-radius: 999px; padding: 4px 8px; display: inline-block; }
    .chip.pass { background: #d1fae5; color: #065f46; }
    .chip.fail { background: #ffe4e6; color: #9f1239; }
    .readouts { display: grid; grid-template-columns: 1fr 1fr; gap: 4px 12px; margin-top: 8px; }
    canvas { width: 100%; height: auto; border-radius: 14px; }
    fieldset { border: 1px solid #e2e8f0; border-radius: 12px; padding: 10px; }
    legend { font-size: 13px; color: #334155; padding: 0 6px; }
    .modes { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 6px; }
    .modes label { border: 1px solid #e2e8f0; padding: 6px 8px; border-radius: 8px; display: flex; align-items: center; gap: 6px; cursor: pointer; }
    .modes input { margin: 0; }
    .legend { font-size: 12px; color: var(--muted); text-align: center; margin-top: 6px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div>
      <h1>Reeb Overload → EM Time Dilation</h1>
      <p class="meta">
        Screen equations: <span class="mono">g'(t)=λ(t,θ)−γg</span>,
        <span class="mono">s(t)=e^{-g(t)}</span>,
        <span class="mono">θ'(t)=ω₀·s(t)</span>,
        <span class="mono">dτ/dt=s(t)</span>. Overload (<span class="mono">s&lt;ε</span>) ⇒ forward skip; underload (<span class="mono">s&gt;ε_hi</span>) ⇒ retrograde skip. Relief is proportional to depth.
      </p>

      <div class="grid2" style="margin-top: 14px;">
        <div class="card" style="display:flex;flex-direction:column;align-items:center;">
          <canvas id="record" width="420" height="420"></canvas>
          <div class="readouts small">
            <div>t (global): <span id="rd-t" class="mono">0.00 s</span></div>
            <div>τ (screen): <span id="rd-tau" class="mono">0.00 s</span></div>
            <div>g (∫λ): <span id="rd-g" class="mono">0.000</span></div>
            <div>s=e^{-g}: <span id="rd-s" class="mono">1.000</span></div>
            <div>θ (phase): <span id="rd-theta" class="mono">0.000 rad</span></div>
            <div>ω inst.: <span id="rd-omega" class="mono">0.000 rad/s</span></div>
          </div>
          <div class="legend">Green: time ⟂ trajectory • Gray: tangent (EM phase)</div>
        </div>

        <div class="card">
          <canvas id="plots" width="420" height="420"></canvas>
          <p class="small" style="margin-top:8px;">
            Plots over recent frames: top = <span class="mono">s(t)=e^{-g(t)}</span>, middle = <span class="mono">g(t)</span>, bottom = <span class="mono">τ(t)</span> shifted to min.
          </p>
        </div>
      </div>
    </div>

    <div class="card">
      <h2 style="margin:0 0 10px 0;">Controls</h2>

      <div class="control">
        <label>Base frequency ω₀ (rad/s)</label>
        <input type="range" id="omega0" min="0.1" max="10" step="0.1" value="2.0" />
        <div class="small mono" id="omega0v">2.00</div>
      </div>

      <div class="row">
        <div class="control">
          <label>Load amplitude κ</label>
          <input type="range" id="kappa" min="0" max="3" step="0.05" value="1.0" />
          <div class="small mono" id="kappav">1.00</div>
        </div>
        <div class="control" id="ctrl-loadfreq">
          <label>Time-mode freq (Hz)</label>
          <input type="range" id="loadFreq" min="0" max="3" step="0.05" value="0.5" />
          <div class="small mono" id="loadFreqv">0.50</div>
        </div>
      </div>

      <div class="row">
        <div class="control" id="ctrl-mharm">
          <label>θ-harmonic m</label>
          <input type="range" id="mHarm" min="1" max="6" step="1" value="1" />
          <div class="small mono" id="mHarmv">1</div>
        </div>
        <div class="control">
          <label>Leak γ (RC relaxation)</label>
          <input type="range" id="leakGamma" min="0" max="2" step="0.01" value="0.00" />
          <div class="small mono" id="leakGammav">0.00</div>
        </div>
      </div>

      <div class="row">
        <div class="control">
          <label>Skip threshold ε (overload)</label>
          <input type="range" id="epsilon" min="0" max="0.8" step="0.01" value="0.2" />
          <div class="small mono" id="epsilonv">0.20</div>
        </div>
        <div class="control">
          <label>Skip threshold ε_hi (underload)</label>
          <input type="range" id="epsilonHi" min="1" max="3" step="0.01" value="1.3" />
          <div class="small mono" id="epsilonHiv">1.30</div>
        </div>
      </div>

      <div class="row">
        <div class="control">
          <label>Skip size Δθ (deg)</label>
          <input type="range" id="skipDeg" min="5" max="120" step="1" value="30" />
          <div class="small mono" id="skipDegv">30°</div>
        </div>
        <div class="control">
          <label>Relief base δg</label>
          <input type="range" id="relief" min="0" max="1" step="0.01" value="0.25" />
          <div class="small mono" id="reliefv">0.25</div>
        </div>
      </div>

      <div class="row">
        <div class="control">
          <label>Relief gain (proportional)</label>
          <input type="range" id="reliefGain" min="0" max="2" step="0.01" value="0.50" />
          <div class="small mono" id="reliefGainv">0.50</div>
        </div>
        <fieldset style="margin-top:10px;">
          <legend>Load mode λ = R h</legend>
          <div class="modes" id="modes">
            <label><input type="radio" name="mode" value="constant"> constant</label>
            <label><input type="radio" name="mode" value="sin_t"> sin(time)</label>
            <label><input type="radio" name="mode" value="sin_theta" checked> sin(θ)</label>
            <label><input type="radio" name="mode" value="pulse"> pulse</label>
            <label><input type="radio" name="mode" value="noise"> noise</label>
          </div>
        </fieldset>
      </div>

      <div style="display:flex; gap:8px; align-items:center; margin-top:12px; flex-wrap:wrap;">
        <button class="btn primary" id="toggle">Pause</button>
        <button class="btn" id="reset">Reset</button>
        <button class="btn green" id="selftest">Run Self-Test</button>
        <span id="testchip" class="chip" style="display:none;"></span>
      </div>

      <p class="small" style="margin-top:10px;">
        <strong>Tip.</strong> Overload redshift: sin(time), κ≈1.5, ε≈0.15.  
        Phase-locked jams: sin(θ), m=3, κ≈2.0, ε≈0.25.  
        Underload blueshift: constant λ&lt;0, ε_hi≈1.3 for retrograde pops.
      </p>
    </div>
  </div>

  <script>
    // --- Utilities ---
    const TAU = Math.PI * 2;
    const clamp = (x, a, b) => Math.min(b, Math.max(a, x));
    const modTau = (x) => ((x % TAU) + TAU) % TAU;

    function makeNoise() {
      let y = 0, v = 0;
      return (dt, amp = 1, stiffness = 4, damping = 1) => {
        const a = -stiffness * y - damping * v + (Math.random() - 0.5) * 4;
        v += a * dt;
        y += v * dt;
        return amp * clamp(y * 0.25, -1.5, 1.5);
      };
    }

    // --- State ---
    let omega0 = 2.0;
    let kappa = 1.0;
    let mode = "sin_theta";
    let loadFreq = 0.5;
    let mHarm = 1;
    let leakGamma = 0.0;

    let epsilon = 0.2;    // overload threshold
    let epsilonHi = 1.3;  // underload threshold
    let skipDeg = 30;
    let relief = 0.25;
    let reliefGain = 0.50;

    let theta = 0;
    let g = 0;
    let tau = 0;
    let tGlobal = 0;
    let lastSkipTime = -999;

    let running = true;
    let lastTs = null;

    const plotN = 600;
    const sHist = Array(plotN).fill(1);
    const gHist = Array(plotN).fill(0);
    const tauHist = Array(plotN).fill(0);

    const noiseStep = makeNoise();

    // --- DOM ---
    const recordCanvas = document.getElementById('record');
    const plotsCanvas  = document.getElementById('plots');
    const rdT    = document.getElementById('rd-t');
    const rdTau  = document.getElementById('rd-tau');
    const rdG    = document.getElementById('rd-g');
    const rdS    = document.getElementById('rd-s');
    const rdTh   = document.getElementById('rd-theta');
    const rdOm   = document.getElementById('rd-omega');

    const elOmega0 = document.getElementById('omega0');
    const elOmega0v = document.getElementById('omega0v');
    const elKappa = document.getElementById('kappa');
    const elKappav = document.getElementById('kappav');
    const elLoadFreq = document.getElementById('loadFreq');
    const elLoadFreqv = document.getElementById('loadFreqv');
    const elMHarm = document.getElementById('mHarm');
    const elMHarmv = document.getElementById('mHarmv');

    const elLeakGamma = document.getElementById('leakGamma');
    const elLeakGammav = document.getElementById('leakGammav');

    const elEpsilon = document.getElementById('epsilon');
    const elEpsilonv = document.getElementById('epsilonv');
    const elEpsilonHi = document.getElementById('epsilonHi');
    const elEpsilonHiv = document.getElementById('epsilonHiv');

    const elSkipDeg = document.getElementById('skipDeg');
    const elSkipDegv = document.getElementById('skipDegv');
    const elRelief = document.getElementById('relief');
    const elReliefv = document.getElementById('reliefv');
    const elReliefGain = document.getElementById('reliefGain');
    const elReliefGainv = document.getElementById('reliefGainv');

    const modesDiv = document.getElementById('modes');
    const ctrlLoadFreq = document.getElementById('ctrl-loadfreq');
    const ctrlMHarm = document.getElementById('ctrl-mharm');

    const btnToggle = document.getElementById('toggle');
    const btnReset  = document.getElementById('reset');
    const btnSelf   = document.getElementById('selftest');
    const testChip  = document.getElementById('testchip');

    // --- Controls wiring ---
    function setDisabled(el, isDisabled) {
      if (isDisabled) { el.classList.add('disabled'); }
      else { el.classList.remove('disabled'); }
      const input = el.querySelector('input[type=range]');
      if (input) input.disabled = !!isDisabled;
    }
    function updateControlVisibility() {
      setDisabled(ctrlLoadFreq, !(mode === 'sin_t' || mode === 'pulse'));
      setDisabled(ctrlMHarm, !(mode === 'sin_theta'));
    }

    elOmega0.addEventListener('input', () => { omega0 = parseFloat(elOmega0.value); elOmega0v.textContent = omega0.toFixed(2); });
    elKappa.addEventListener('input', () => { kappa = parseFloat(elKappa.value); elKappav.textContent = kappa.toFixed(2); });
    elLoadFreq.addEventListener('input', () => { loadFreq = parseFloat(elLoadFreq.value); elLoadFreqv.textContent = loadFreq.toFixed(2); });
    elMHarm.addEventListener('input', () => { mHarm = parseInt(elMHarm.value, 10); elMHarmv.textContent = mHarm.toString(); });

    elLeakGamma.addEventListener('input', () => { leakGamma = parseFloat(elLeakGamma.value); elLeakGammav.textContent = leakGamma.toFixed(2); });

    elEpsilon.addEventListener('input', () => { epsilon = parseFloat(elEpsilon.value); elEpsilonv.textContent = epsilon.toFixed(2); });
    elEpsilonHi.addEventListener('input', () => { epsilonHi = parseFloat(elEpsilonHi.value); elEpsilonHiv.textContent = epsilonHi.toFixed(2); });

    elSkipDeg.addEventListener('input', () => { skipDeg = parseFloat(elSkipDeg.value); elSkipDegv.textContent = skipDeg.toFixed(0) + '°'; });
    elRelief.addEventListener('input', () => { relief = parseFloat(elRelief.value); elReliefv.textContent = relief.toFixed(2); });
    elReliefGain.addEventListener('input', () => { reliefGain = parseFloat(elReliefGain.value); elReliefGainv.textContent = reliefGain.toFixed(2); });

    modesDiv.addEventListener('change', (e) => {
      if (e.target && e.target.name === 'mode') {
        mode = e.target.value;
        updateControlVisibility();
      }
    });

    btnToggle.addEventListener('click', () => {
      running = !running;
      btnToggle.textContent = running ? 'Pause' : 'Play';
      if (running) { lastTs = null; requestAnimationFrame(loop); }
    });

    btnReset.addEventListener('click', () => {
      theta = 0; g = 0; tau = 0; tGlobal = 0; lastSkipTime = -999; lastTs = null;
      for (let i=0;i<plotN;i++) { sHist[i]=1; gHist[i]=0; tauHist[i]=0; }
      testChip.style.display = 'none';
    });

    btnSelf.addEventListener('click', runSelfTest);

    updateControlVisibility();
    elOmega0v.textContent = omega0.toFixed(2);
    elKappav.textContent = kappa.toFixed(2);
    elLoadFreqv.textContent = loadFreq.toFixed(2);
    elMHarmv.textContent = mHarm.toString();
    elLeakGammav.textContent = leakGamma.toFixed(2);
    elEpsilonv.textContent = epsilon.toFixed(2);
    elEpsilonHiv.textContent = epsilonHi.toFixed(2);
    elSkipDegv.textContent = skipDeg.toFixed(0) + '°';
    elReliefv.textContent = relief.toFixed(2);
    elReliefGainv.textContent = reliefGain.toFixed(2);

    // --- Simulation core ---
    function lambdaFn(dt, t, th) {
      switch (mode) {
        case 'constant':  return kappa;
        case 'sin_t':     return kappa * Math.sin(2 * Math.PI * loadFreq * t);
        case 'sin_theta': return kappa * Math.sin(mHarm * th);
        case 'pulse': {
          const phase = (t * loadFreq) % 1;
          return kappa * (phase < 0.5 ? 1 : -1);
        }
        case 'noise':     return noiseStep(dt, kappa);
        default:          return 0;
      }
    }

    function loop(ts) {
      if (!running) return;
      if (lastTs === null) { lastTs = ts; requestAnimationFrame(loop); return; }
      const dt = Math.min(50, Math.max(0, ts - lastTs)) / 1000; // clamp to 50ms
      lastTs = ts;

      // advance global time
      tGlobal += dt;

      // integrate g'(t) = λ − γ g
      const lam = lambdaFn(dt, tGlobal, theta);
      let gdot = lam - leakGamma * g;
      g += gdot * dt;
      g = clamp(g, -8, 8);

      // s = e^{-g}; ω_inst = ω0 * s; θ' = ω_inst
      const s = Math.exp(-g);
      const omegaInst = omega0 * s;
      const dtheta = omegaInst * dt;

      // skip logic with twin thresholds + cooldown
      const coolDown = 0.2;
      let justSkipped = false;
      if ((tGlobal - lastSkipTime) > coolDown && s < epsilon) {
        // overload → forward skip
        theta = modTau(theta + (skipDeg * Math.PI / 180));
        const depth = clamp(epsilon - s, 0, 5);
        const deltaG = clamp(relief + reliefGain * depth, 0, 2);
        g -= deltaG; g = clamp(g, -8, 8);
        lastSkipTime = tGlobal; justSkipped = true;
      } else if ((tGlobal - lastSkipTime) > coolDown && s > epsilonHi) {
        // underload → retrograde skip
        theta = modTau(theta - (skipDeg * Math.PI / 180));
        const depth = clamp(s - epsilonHi, 0, 5);
        const deltaG = clamp(relief + reliefGain * depth, 0, 2);
        g += deltaG; g = clamp(g, -8, 8);
        lastSkipTime = tGlobal; justSkipped = true;
      } else {
        theta = modTau(theta + dtheta);
      }

      // effective screen time
      tau += s * dt;

      // histories
      sHist.push(s); if (sHist.length > plotN) sHist.shift();
      gHist.push(g); if (gHist.length > plotN) gHist.shift();
      tauHist.push(tau); if (tauHist.length > plotN) tauHist.shift();

      // draw + readouts
      drawRecordCanvas(recordCanvas, { theta, s, g, omegaInst, lambda: lam, t: tGlobal, justSkipped });
      drawPlotsCanvas(plotsCanvas, { sHist, gHist, tauHist });

      rdT.textContent = tGlobal.toFixed(2) + ' s';
      rdTau.textContent = tau.toFixed(2) + ' s';
      rdG.textContent = g.toFixed(3);
      rdS.textContent = s.toFixed(3);
      rdTh.textContent = theta.toFixed(3) + ' rad';
      rdOm.textContent = omegaInst.toFixed(3) + ' rad/s';

      requestAnimationFrame(loop);
    }

    // --- Drawing helpers ---
    function roundRect(ctx, x, y, w, h, r) {
      // JS comments only; avoid shell '#' comments.
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
    }

    function drawRecordCanvas(canvas, { theta, s, g, omegaInst, lambda, t, justSkipped }) {
      if (!canvas) return;
      const W = canvas.width, H = canvas.height;
      const ctx = canvas.getContext('2d');
      ctx.save();
      ctx.clearRect(0, 0, W, H);

      const cx = W / 2, cy = H / 2;
      const R = Math.min(W, H) * 0.42;

      // background
      ctx.fillStyle = '#f8fafc';
      ctx.fillRect(0, 0, W, H);

      // disk base
      const grooves = 9;
      ctx.beginPath();
      ctx.arc(cx, cy, R, 0, TAU);
      ctx.fillStyle = '#0f172a';
      ctx.fill();

      // grooves
      for (let i = 0; i < grooves; i++) {
        const r = R * (1 - 0.05 * i);
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, TAU);
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      // label
      ctx.beginPath();
      ctx.arc(cx, cy, R * 0.28, 0, TAU);
      ctx.fillStyle = '#e2e8f0';
      ctx.fill();

      // stylus point
      const rStylus = R * 0.92;
      const x = cx + rStylus * Math.cos(theta);
      const y = cy + rStylus * Math.sin(theta);

      // tangent & normal
      const tx = -Math.sin(theta), ty = Math.cos(theta);
      const nx = Math.cos(theta), ny = Math.sin(theta);

      // time arrow (scaled by s)
      const timeLen = 50 * Math.max(0.1, s);
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + nx * timeLen, y + ny * timeLen);
      ctx.strokeStyle = '#10b981';
      ctx.lineWidth = 3;
      ctx.stroke();

      // arrow head
      ctx.beginPath();
      ctx.moveTo(x + nx * timeLen, y + ny * timeLen);
      ctx.lineTo(x + nx * timeLen - 8 * nx - 5 * ny, y + ny * timeLen - 8 * ny + 5 * nx);
      ctx.lineTo(x + nx * timeLen - 8 * nx + 5 * ny, y + ny * timeLen - 8 * ny - 5 * nx);
      ctx.closePath();
      ctx.fillStyle = '#10b981';
      ctx.fill();

      // tangent marker
      ctx.beginPath();
      ctx.moveTo(x - tx * 18, y - ty * 18);
      ctx.lineTo(x + tx * 18, y + ty * 18);
      ctx.strokeStyle = '#94a3b8';
      ctx.lineWidth = 3;
      ctx.stroke();

      // highlight on skip
      if (justSkipped) {
        ctx.beginPath();
        ctx.arc(cx, cy, rStylus + 6, 0, TAU);
        ctx.strokeStyle = 'rgba(244,63,94,0.8)';
        ctx.lineWidth = 6;
        ctx.stroke();
      }

      // HUD panel
      const panelW = 200, panelH = 96;
      const px = cx - panelW / 2, py = cy - R - 10 < 10 ? 10 : cy - R - 10;
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.strokeStyle = 'rgba(15,23,42,0.15)';
      ctx.lineWidth = 1;
      roundRect(ctx, px, py, panelW, panelH, 10);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = '#0f172a';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, monospace';
      ctx.fillText('λ (Rh): ' + lambda.toFixed(3), px + 10, py + 20);
      ctx.fillText('g: ' + g.toFixed(3) + '   s=e^{-g}: ' + Math.exp(-g).toFixed(3), px + 10, py + 38);
      ctx.fillText('ω_inst: ' + omegaInst.toFixed(3) + ' rad/s', px + 10, py + 56);

      ctx.restore();
    }

    function drawPlotsCanvas(canvas, { sHist, gHist, tauHist }) {
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const W = canvas.width, H = canvas.height;
      ctx.save();
      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, W, H);

      const pad = 24;
      const rowH = (H - pad * 2) / 3;

      function drawSeries(y0, series, color, label, autoZero=false) {
        const n = series.length;
        if (!n) return;
        const min = Math.min(...series);
        const max = Math.max(...series);
        const lo = autoZero ? min : Math.min(min, 0);
        const hi = autoZero ? max : Math.max(max, 1e-6);
        const scaleX = (W - pad * 2) / Math.max(1, n - 1);
        const scaleY = (rowH - 18) / ((hi - lo) || 1);

        ctx.strokeStyle = '#e2e8f0';
        ctx.lineWidth = 1;
        ctx.strokeRect(pad, y0, W - pad * 2, rowH);

        ctx.strokeStyle = 'rgba(100,116,139,0.4)';
        ctx.beginPath();
        const yZero = y0 + rowH - (0 - lo) * scaleY;
        ctx.moveTo(pad, yZero);
        ctx.lineTo(W - pad, yZero);
        ctx.stroke();

        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i < n; i++) {
          const x = pad + i * scaleX;
          const y = y0 + rowH - (series[i] - lo) * scaleY;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();

        ctx.fillStyle = '#334155';
        ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto';
        ctx.fillText(label, pad + 6, y0 + 16);
      }

      drawSeries(pad, sHist, '#0ea5e9', 's(t) = e^{-g(t)}');
      drawSeries(pad + rowH, gHist, '#f43f5e', 'g(t)');
      const tauMin = Math.min(...tauHist);
      const tauShifted = tauHist.map(v => v - tauMin);
      drawSeries(pad + 2*rowH, tauShifted, '#10b981', 'τ(t) (min-shifted)', true);

      ctx.restore();
    }

    // --- Self-tests (runtime) ---
    function runSelfTest() {
      try {
        // 1) roundRect should render without throwing
        const c1 = document.createElement('canvas');
        c1.width = 200; c1.height = 200;
        const k1 = c1.getContext('2d');
        k1.fillStyle = '#000';
        roundRect(k1, 20, 20, 160, 100, 12);
        k1.fill();

        // 2) drawRecordCanvas handles skip highlight
        const c2 = document.createElement('canvas');
        c2.width = 300; c2.height = 300;
        drawRecordCanvas(c2, {
          theta: 0.75, s: 0.05, g: 3.0,
          omegaInst: 0.1, lambda: 0.5, t: 0,
          justSkipped: true
        });

        // 3) drawPlotsCanvas accepts histories
        const c3 = document.createElement('canvas');
        c3.width = 360; c3.height = 240;
        drawPlotsCanvas(c3, {
          sHist: [1, 0.9, 0.7, 0.4, 0.6, 0.8],
          gHist: [0, 0.1, 0.3, 0.6, 0.5, 0.2],
          tauHist: [0, 0.05, 0.12, 0.16, 0.23, 0.31]
        });

        // 4) Deterministic forward skip (overload): expect ≥1 skip
        let th = 0, gL = 0, tL = 0, lastK = -999, skipsFwd = 0;
        const eps = 0.1;
        for (let i = 0; i < 240; i++) { // ~4s at 60fps
          const dt = 1/60; tL += dt;
          const lam = 2.0; // constant overload
          gL += (lam - 0 * gL) * dt; gL = clamp(gL, -8, 8);
          const s = Math.exp(-gL);
          if (s < eps && (tL - lastK) > 0.2) {
            th = modTau(th + (45 * Math.PI / 180));
            const depth = clamp(eps - s, 0, 5);
            const deltaG = clamp(0.25 + 0.5 * depth, 0, 2);
            gL -= deltaG; gL = clamp(gL, -8, 8);
            lastK = tL; skipsFwd++;
          } else {
            const om = 2.0 * s;
            th = modTau(th + om * dt);
          }
        }
        if (skipsFwd < 1) throw new Error("Forward skip test failed (no overload skip).");

        // 5) Deterministic retrograde skip (underload): expect ≥1 skip
        th = 0; gL = 0; tL = 0; lastK = -999; let skipsBack = 0;
        for (let i = 0; i < 240; i++) {
          const dt = 1/60; tL += dt;
          const lam = -2.0; // constant underload
          gL += (lam - 0 * gL) * dt; gL = clamp(gL, -8, 8);
          const s = Math.exp(-gL);
          if (s > 1.3 && (tL - lastK) > 0.2) {
            th = modTau(th - (45 * Math.PI / 180));
            const depth = clamp(s - 1.3, 0, 5);
            const deltaG = clamp(0.25 + 0.5 * depth, 0, 2);
            gL += deltaG; gL = clamp(gL, -8, 8);
            lastK = tL; skipsBack++;
          } else {
            const om = 2.0 * s;
            th = modTau(th + om * dt);
          }
        }
        if (skipsBack < 1) throw new Error("Retrograde skip test failed (no underload skip).");

        // 6) Proportional relief monotonicity (pure formula check)
        const deltaG_shallow = clamp(0.25 + 0.5 * clamp(0.05, 0, 5), 0, 2);
        const deltaG_deep    = clamp(0.25 + 0.5 * clamp(0.25, 0, 5), 0, 2);
        if (!(deltaG_deep > deltaG_shallow)) throw new Error("Relief gain monotonicity failed.");

        // 7) Leak relaxation: with λ=0, g should decay toward 0 for γ>0
        gL = 2.0; const gammaTest = 0.5;
        for (let i = 0; i < 240; i++) {
          const dt = 1/60;
          const lam = 0;
          gL += (lam - gammaTest * gL) * dt;
        }
        if (!(Math.abs(gL) < 1.0)) throw new Error("Leak relaxation failed (g did not decrease).");

        testChip.className = "chip pass";
        testChip.textContent = "PASS: All self-tests passed.";
        testChip.style.display = "inline-block";
      } catch (err) {
        testChip.className = "chip fail";
        testChip.textContent = "FAIL: " + (err && err.message ? err.message : String(err));
        testChip.style.display = "inline-block";
      }
    }

    // kick things off
    requestAnimationFrame(loop);
  </script>
</body>
</html>
